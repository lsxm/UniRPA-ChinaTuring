// This file is used in background side (only WrapInGlobalContext) and on content side (WrapInjectedFunction & WrapInGlobalContext)var g_functionNameThatWillBeCalled = "";var g_functionThatWillBeCalled = null;var g_globalContext; // leave uninitialized, see WrapContentCode// These global variables are the ones used in browser extension before `WrapInGlobalContext` existed. In webdriver support they are not defined (see also CustomIdCache.js).// They have to be initialized in this file because this file is used only for browser extension (and not for webdriver) and because CusomIdCache.js has to have only one single WrapInGlobalContext call// (so that it can be used in webdriver)var g_isCustomCacheInitialized;var g_customIdCache;var g_crtCustomIdValue;if (g_isCustomCacheInitialized !== true) {        g_isCustomCacheInitialized = true;        // ResetCustomIdCache();        g_customIdCache = {};        g_crtCustomIdValue = 0;    
}// function used only on Content sidefunction WrapInjectedFunction(funcName, func) {        // funcName actualy used only in browser support via webdriver, where WrapInjectedFunction has a different implementation        // In UiPath Browser Extension is used only for logging purposes.        g_functionNameThatWillBeCalled = funcName;        g_functionThatWillBeCalled = func;    
}// function used only on Content and Backgroundfunction WrapInGlobalContext(func) {        // func must be something like function func(){ ... this.var = value; this.g = function(){} ...}        // func will be assigned into an object before beeing invoked, so that `this` will be accesible            // because we want to preserve g_customIdCache, we reset context only at first initialization        // on subsequent initializations (from newer driver versions on the same page) keep g_customIdCache        if ("undefined" == typeof g_globalContext)            g_globalContext = {};            //console.log("WrapInGlobalContext: before adding the object is: " + JSON.stringify(g_globalContext));        //for (var id in g_globalContext)         //    if (typeof (g_globalContext[id]) == "function")        //        console.log("function " + id + ": " + g_globalContext[id].toString());            g_globalContext.__EnrichContextFunc = func;        g_globalContext.__EnrichContextFunc();        g_globalContext.__EnrichContextFunc = null;            //console.log("WrapInGlobalContext: after adding the object is: " + JSON.stringify(g_globalContext));        //for (var id in g_globalContext)        //    if (typeof (g_globalContext[id]) == "function")        //        console.log("function " + id + ": " + g_globalContext[id].toString());        
}WrapInGlobalContext(function () {            var gcontext = this;        gcontext.xbrowser = function () {            var isMozilla = false;            var isEdgeBrowser = false;            var modeSingleFrame = false;            var chromeVersion = 0;                    return {                    init: function () {                            isEdgeBrowser = typeof CSS !== 'undefined' && CSS.supports("(-ms-ime-align:auto)");                            isMozilla = window.mozInnerScreenX !== undefined;                            chromeVersion = parseInt((/Chrome\/([0-9]+)/.exec(navigator.userAgent) || ["0", "0"])[1]);                                            // Edge and Chrome prior to 41 don't have per-frame messaging support                            modeSingleFrame = isEdgeBrowser || (chromeVersion > 0 && chromeVersion < 41);                                            if (chrome.tabs && !chrome.tabs.getSelected) {                                    chrome.tabs.getSelected = function (wndId, response) {                                            return chrome.tabs.query({ active: true, windowId: wndId }, function (tabsArray) {                                                    response(tabsArray[0]);                            
                        });                        
                    };                    
                }                                            if (chrome.extension && !chrome.extension.onMessage) {                                    chrome.extension.onMessage = {                                            addListener: function (callback) {                                                    return chrome.runtime.onMessage.addListener(callback);                            
                        },                                                                    removeListener: function (callback) {                                                    return chrome.runtime.onMessage.removeListener(callback);                            
                        }                        
                    };                    
                }                                            if (chrome.tabs && !chrome.tabs.getZoom) {                                    chrome.tabs.getZoom = function (tabId, callback) {                                            // NOTE: for Edge, zoom is accounted for in pixel density, so there's no need for getZoom                                            gcontext.TraceMessage("Warning: chrome.tabs.getZoom() is undefined. Return 100% zoom. User Agent: " + navigator.userAgent);                                            callback(1);                        
                    };                    
                }                
            },                                tabs: {                            sendMessage: function (tabId, message, frameId, responseCallback) {                                    gcontext.TraceMessage("Single frame mode: \"" + modeSingleFrame + "\", userAgent: " + navigator.userAgent);                                    if (modeSingleFrame) {                                            // older Chrome versions which lack per-frame messaging support, expect only 3 arguments                                            chrome.tabs.sendMessage(tabId, message, responseCallback);                        
                    }                                    else {                                            chrome.tabs.sendMessage(tabId, message, { frameId: frameId }, responseCallback);                        
                    }                
            }            
        },                        isFirefox: function () {                        return isMozilla            
        },                isEdge: function () {                        return isEdgeBrowser            
        },                isModeSingleFrame: function () {                        return modeSingleFrame;            
        }        
    }    
}();gcontext.xbrowser.init();}); // WrapInGlobalContext// don't wrap N_* constants// they are used in too many places and the code would be too uglyvar N_TRUE = 1;var N_FALSE = 0;WrapInGlobalContext(function () {            var gcontext = this;            // String matching with wildcards    gcontext.MatchChars = function (c1, c2) {            return (c1 === '?') || (c1 === c2);        
    }        // String matching with wildcards for prefix computing    gcontext.MatchCharsPrefix = function (c1, c2) {            return (c1 === '?') || (c2 === '?') || (c1 === c2);        
    }        gcontext.ComputePrefixFunction = function (pattern, beginPattern, patternLen) {                    var state = -1;            var pi = new Array(patternLen);            pi[0] = state;                    var i;            for (i = 1; i < patternLen; ++i) {                    while (state > -1 && !gcontext.MatchCharsPrefix(pattern[beginPattern + state + 1], pattern[beginPattern + i])) {                            state = pi[state];                
            }                    if (gcontext.MatchCharsPrefix(pattern[beginPattern + i], pattern[beginPattern + state + 1])) {                            state++;                
            }                    pi[i] = state;            
        }            return pi;        
    }        gcontext.StringWildcardMatch = function (psPattern, psText) {            gcontext.TraceMessage("StrWildcardMatch(psPattern: " + psPattern + " psText: " + psText);                    if (psPattern == null || psText == null) {                   gcontext.TraceMessage("StringWildcardMatch: invalid input, return false");                   return false;            
        }                    // empty pattern can only be matched by empty string            if (psPattern === "") {                    return (psText === "");            
        }                    var beginPattern = 0;            var beginText = 0;            var endPattern = psPattern.length - 1;            var endText = psText.length - 1;                    // if the pattern is not begining with '*'            // then match the prefix            if (psPattern[beginPattern] != '*') {                    while (psPattern[beginPattern] != '*' && beginPattern <= endPattern && beginText <= endText) {                            if (!gcontext.MatchChars(psPattern[beginPattern], psText[beginText])) {                                    return false;                    
                }                            ++beginPattern;                            ++beginText;                
            }            
        }                    // if the pattern is not ending with '*'            // then match the suffix            if (psPattern[endPattern] != '*') {                    while (psPattern[endPattern] != '*' && beginPattern <= endPattern && beginText <= endText) {                            if (!gcontext.MatchChars(psPattern[endPattern], psText[endText])) {                                    return false;                    
                }                            --endPattern;                            --endText;                
            }            
        }                    // if there are no more characters in the pattern            // then there was no '*' character, in which case             // the string should have matched completely             if (beginPattern > endPattern) {                    return (beginText > endText);            
        }                            // the pattern should look like *s1*s2*...*sn*            // if not, the string does not match the pattern            if (psPattern[beginPattern] != '*' || psPattern[endPattern] != '*') {                    return false;            
        }                    while (beginPattern <= endPattern) {                    // skip all the strating '*'                    while (psPattern[beginPattern] == '*' && beginPattern <= endPattern) {                            beginPattern++;                
            }                    if (beginPattern > endPattern) {                            break;                
            }                                var substrLen = 0;                    while (psPattern[beginPattern + substrLen] != '*') {                            ++substrLen;                
            }                                            var pi = gcontext.ComputePrefixFunction(psPattern, beginPattern, substrLen);                    var state = -1;                    var canMatch = false;                                for (; beginText <= endText; ++beginText) {                            while (state > -1 && !gcontext.MatchChars(psPattern[beginPattern + state + 1], psText[beginText])) {                                    state = pi[state];                    
                }                            if (gcontext.MatchChars(psPattern[beginPattern + state + 1], psText[beginText])) {                                    state++;                    
                }                            if (state == substrLen - 1) {                                    canMatch = true;                                    break;                    
                }                
            }                                // we could not find a match                     // therefore the string does not match the pattern                    if (!canMatch) {                            return false;                
            }                    beginPattern += substrLen;                    ++beginText;            
        }                    // we could match all the substrings            return true;        
    }            gcontext.DeleteForbiddenCharacters = function (text) {            if (text == null || text.length === 0) {                    return "";            
        }                    var out_text = text.replace(/\r/g, " ");            out_text = out_text.replace(/\n/g, " ");                    return out_text;        
    }        gcontext.TruncateStringUsingWildcard = function (text, maxLen) {            if (text == null) {                    return "";            
        }                    if (text.length <= maxLen) {                    return text;            
        }                    var out_text = text.slice(0, maxLen);            out_text += "*";                    return out_text;        
    }        gcontext.ConcatObjects = function (o1, o2) {            var result = {};                    if (o1 != null) {                    result = o1;            
        }                    if (o2 != null) {                    for (var prop in o2) {                            result[prop] = o2[prop];                
            }            
        }                    return result;        
    }        gcontext.IsObjectEmpty = function (obj) {            if (obj == null) {                    return true;            
        }                    for (var prop in obj) {                    if (obj.hasOwnProperty(prop)) {                            return false;                
            }            
        }                    return true;        
    }        gcontext.TrimWhiteSpaces = function (text) {            // Trim the standard white spaces.            var out_text = text.trim();                    // Trim special white space characters.            var whiteSpaceCodes = [0x200E, 0x2022];            while (out_text.length !== 0 &&                   whiteSpaceCodes.indexOf(out_text.charCodeAt(0)) !== -1) {            out_text = out_text.slice(1);    
}    while (out_text.length !== 0 &&           whiteSpaceCodes.indexOf(out_text.charCodeAt(out_text.length - 1)) !== -1) {            out_text = out_text.slice(0, out_text.length - 1);    
}    return out_text;}gcontext.IsWhiteSpaceCharacter = function (ch) {        //Trim the standard white spaces.        return ch === '\t' ||               ch === '\r' ||               ch === '\n' ||               ch === ' ' ||               ch === '\u200E' ||               ch === '\u2022';    
}gcontext.UiRect = function UiRect(left, top, width, height) {        return {                left: left,                top: top,                right: left + width,                bottom: top + height,                getWidth: function () { return this.right - this.left; },                getHeight: function () { return this.bottom - this.top; },                        Intersects: function (rc2) {                        return (this.right > rc2.left && this.left < rc2.right) &&                               (this.bottom > rc2.top && this.top < rc2.bottom);            
        },                        Contains: function (point) {                        return ((point.x >= this.left && point.x <= this.right) &&                                (point.y >= this.top && point.y <= this.bottom));            
        },                        Scale: function (factor) {                        return UiRect(this.left * factor, this.top * factor, this.getWidth() * factor, this.getHeight() * factor);            
        },                        ScaleInv: function (factor) {                        return UiRect(this.left / factor, this.top / factor, this.getWidth() / factor, this.getHeight() / factor);            
        },                        IsEqual: function (rc2) {                        return this.left === rc2.left && this.top === rc2.top &&                               this.right === rc2.right && this.bottom === rc2.bottom;            
        },                        Offset: function (dx, dy) {                        return UiRect(this.left + dx, this.top + dy, this.getWidth(), this.getHeight());            
        },                        MathRound: function () {                        return UiRect(Math.round(this.left), Math.round(this.top), Math.round(this.getWidth()), Math.round(this.getHeight()));            
        },                        toString: function () {                        return "(" + left + " " + top + " " + width + " " + height + ")";            
        }        
    };    
}gcontext.RectToString = function (rect) {        return "[" + rect.left + " " + rect.top + " " + rect.right + " " + rect.bottom + "]";    
}gcontext.UnformatSpecialJsCharacters = function (code) {        var out_unformattedCode = code;            out_unformattedCode = out_unformattedCode.replace(/%CR%/g, "\r");        out_unformattedCode = out_unformattedCode.replace(/%LF%/g, "\n");            return out_unformattedCode    
}gcontext.ExecuteWithRetry = function (predicateFunc, coreFunc, debugTag){        var initTimeout = 30000; // 30 seconds        var timeout = 100;        var maxTries = initTimeout / timeout;            var fnWrapper = function ()        {                if (predicateFunc() === true)                {                        coreFunc();            
        }                else                {                        maxTries--;                                    if (maxTries >= 0)                        {                                gcontext.TraceMessage("ExecuteWithRetry: condition for " + debugTag + " is false; retrying later");                                setTimeout(fnWrapper, timeout);                
            }                        else                        {                                gcontext.TraceMessage("ExecuteWithRetry: timed out while waiting to execute '" + debugTag + "'");                
            }            
        }        
    };            fnWrapper();    
}gcontext.Stopwatch = function () {        var m_startTime;        var m_msTimeout;        var m_bTimeoutElapsed;            return {                Start: function (msTimeout) {                        m_msTimeout = msTimeout;                        m_bTimeoutElapsed = N_FALSE;                        m_startTime = new Date().getTime();            
        },                        TimeoutElapsed: function () {                        if (m_bTimeoutElapsed === N_FALSE)                        {                                var crtTime = new Date().getTime();                                if (crtTime - m_startTime > m_msTimeout)                                    m_bTimeoutElapsed = N_TRUE;                
            }                                    return m_bTimeoutElapsed;            
        }        
    };    
}}); // WrapInGlobalContextWrapInGlobalContext(function () {            var gcontext = this;        gcontext.getAccName = function (e) {        	if (!e) {            		return "";            
        }                	var tag = e.tagName.toUpperCase();        	if (!isAaElem()) {            		// Use element text.                    return replaceNewLines(getShortElementText());            
        }        	else { // Simulate IE active accessibility name.            		var type = getType();                        		if ("TABLE" === tag) {                			return tableAccName();                
            }            		else {                			return computeAccName();                
            }            
        }                    // Return only this element's text instead of using innertext/textcontent which returns the content of all subtree            function getShortElementText() {                    child = e.firstChild;                    texts = [];                                while (child) {                            if (child.nodeType == 3) {                                    texts.push(child.data);                    
                }                            child = child.nextSibling;                
            }                                return texts.join("");            
        }                    function getElementText() {                    return e.textContent;            
        }                	///////////////////////////////////////////////////////////////////////////////////////////////////////////        	function tableAccName() {            		var title = getTitle();            		if (title !== "") {                			return title;                
            }                        		var captions = e.getElementsByTagName("caption");            		if (captions && (captions.length > 0)) {                			return replaceNewLines(captions[0].textContent);                
            }                        		var headers = e.getElementsByTagName("th");            		var res = "";                        		for (var h = 0; h < headers.length; ++h) {                			var crntText = headers[h].textContent;                                			if (crntText.length > 0) {                    				crntText = trimText(crntText);                                        				if (h > 0) {                        					res += " ";                        
                    }                                        				res += crntText;                    
                }                                
            }                        		return replaceNewLines(res);            
        }                	function trimText(strParam) {            		return strParam.replace(/^\s*/, "").replace(/\s*$/, "");            
        }                	// In IE we use AA only for some types of elements. See HTMLTools.cpp, line 1535, HTMLTools::GetHtmlAAName        	function isAaElem() {            		return (("A" === tag) || ("INPUT" === tag) || ("IMG" === tag) || ("BUTTON" === tag) ||            			    ("TEXTAREA" === tag) || ("AREA" === tag) || ("SELECT" === tag) || ("TABLE" === tag));	}    // The character range for valid XML is defined here: https://en.wikipedia.org/wiki/Valid_characters_in_XML, see the range specified for 'Char'    // WARNING: too painful to include supplementary planes, these characters (0x10000 and higher)     // will be stripped by this function. See what you are missing (heiroglyphics, emoji, etc) at:    // http://en.wikipedia.org/wiki/Plane_(Unicode)#Supplementary_Multilingual_Plane    // C01 and C1 remaining control characters are found at U+007F-U+0084 and U+0086-U+009F    // Code points allowed but discouraged U+FDD0-U+FDEF (non characters)    function sanitizeStringForXML(theString) {            var NOT_SAFE_IN_XML_1_0 = /[^\x09\x0A\x0D\x20-\x7E\x85\xA0-\uD7FF\uE000-\uFDCF\uFDF0-\uFFFD]/gm;            return theString.replace(NOT_SAFE_IN_XML_1_0, '');    
}	function replaceNewLines(text) {        	if ((null === text) || (0 === text.length)) {                	return "";        
    }        	    var result = text.replace(/\r/g, " ");            result = result.replace(/\n/g, " ");            result = sanitizeStringForXML(result);    		return result;    
}	function getType() {    		if (("INPUT" === tag) && e.hasAttribute("type")) {        			return e.type.toUpperCase();        
    }    		else {        			return "";        
    }    
}	function getLabel() {    		if (("A" === tag) || ("BUTTON" === tag) || ("SUBMIT" === type) || ("RESET" === type) || ("BUTTON" === type)) {        			// label has no effect on these elements.        			return "";        
    }        		if (e.id && (e.id !== "")) {        			var doc = e.ownerDocument;        			var labels = doc.getElementsByTagName("label");                	        for (var i = 0; i < labels.length; ++i) {            	        	var crntLabel = labels[i];            	            if (crntLabel.hasAttribute("for")) {                	                var forID = crntLabel.getAttribute("for");                                	                if (forID === e.id) {                    	                    return replaceNewLines(crntLabel.textContent);                    
                }                
            }            
        }        
    }        		// The element has no ID so it can't have a label; or no label found.    		return ""    
}	function getTitle() {    		if (e.hasAttribute("title")) {        			return replaceNewLines(e.getAttribute("title"));        
    }    		else {        			return "";        
    }    
}	function getAlt() {    		if (e.hasAttribute("alt")) {        			return replaceNewLines(e.getAttribute("alt"));        
    }    		else {        			return "";        
    }    
}	function getText() {    		if (("BUTTON" === type) || ("SUBMIT" === type) || ("RESET" === type)) {        			return replaceNewLines(e.value);        
    }                if (("A" === tag) || ("BUTTON" === tag)) {                    return replaceNewLines(getElementText());        
    }        		return "";    
}	function computeAccName() {    		var label = getLabel();    		var title = getTitle();    		var alt = getAlt();    		var text = getText();        		if (("BUTTON" === type) || ("RESET" === type) || ("SUBMIT" === type) || ("BUTTON" === tag)) {        			return getFirstNotEmpty(title, text);        
    }        		if ("IMAGE" === type) {        			return getFirstNotEmpty(title, alt, label);        
    }        		if ("IMG" === tag) {        			var res = getFirstNotEmpty(title, alt, label);        			if (res === "") {            				var parentAnchor = getParentByTag(e, "A");                            return gcontext.getAccName(parentAnchor);            
        }                			return res;        
    }        		return getFirstNotEmpty(label, text, title, alt);    
}	function getFirstNotEmpty() {    		for (var a = 0; a < arguments.length; ++a) {        			var crntArg = arguments[a];        			if (crntArg && crntArg !== "") {            				return crntArg;            
        }        
    }        		return "";    
}	function getParentByTag(elem, parentTag) {    		parentTag = parentTag.toUpperCase();        		var ELEMENT_NODE_TYPE = 1;    	    var resultElement = null;    	    var crntNode = elem;        	    while (true) {        	        var parent = crntNode.parentNode;        	        if ((parent == null) || (parent.nodeType !== ELEMENT_NODE_TYPE)) {            	            // Top of the hierarchy reached.            	            break;            
        }                	        if (parentTag === parent.tagName.toUpperCase()) {            	            // Parent meeting the condition found!            	            resultElement = parent;            	            break;            
        }        	        else {            	            crntNode = parent;            
        }        
    }        	    return resultElement;    
}}}); // WrapInGlobalContext/*	Module that implements the algorithm that recursively finds all documents inside a window.	Public functions:		GetDocumentList(rootDoc) returns the list of documents starting from the root document and recursively in any subframe window.*/WrapInGlobalContext(function () {            var gcontext = this;        //If a website has a child frame which belongs to another domain, an exception can be thrown when trying to access    //"frame.contentDocument". Guard against this case.    gcontext.GetSafeContentDocument = function (frame)    {        	var out_doc = null;                	try        	{            		out_doc = frame.contentDocument;            
        }        	catch (e)        	{            		out_doc = null;            
        }                	return out_doc;        
    }        gcontext.GetDocumentListRecursive = function (doc, out_docList)    {            if (doc == null)        		return;                	var i = 0;                	out_docList.push(doc);                	var frames = doc.getElementsByTagName("iframe");        	for (i = 0; i < frames.length; ++i)                gcontext.GetDocumentListRecursive(gcontext.GetSafeContentDocument(frames.item(i)), out_docList);                	frames = doc.getElementsByTagName("frame");        	for (i = 0; i < frames.length; ++i)                gcontext.GetDocumentListRecursive(gcontext.GetSafeContentDocument(frames.item(i)), out_docList);        
    }        gcontext.GetDocumentList = function (rootDoc)    {            if (!gcontext.IsMainFrame(window)) {                    return [rootDoc];            
        }                    var docList = [];            gcontext.GetDocumentListRecursive(rootDoc, docList);        	return docList;        
    }        gcontext.GetFrameListRecursive = function (doc, out_frameList)    {            if (doc == null)        		return;                	var i = 0;                	var frames = doc.getElementsByTagName("iframe");        	for (i = 0; i < frames.length; ++i)        	{                    var frame = frames.item(i);            		out_frameList.push(frame);            		gcontext.GetFrameListRecursive(gcontext.GetSafeContentDocument(frame), out_frameList);            
        }                	frames = doc.getElementsByTagName("frame");        	for (i = 0; i < frames.length; ++i)        	{                    var frame = frames.item(i);            		out_frameList.push(frame);            		gcontext.GetFrameListRecursive(gcontext.GetSafeContentDocument(frame), out_frameList);            
        }        
    }        gcontext.GetFrameList = function (rootDoc)    {            var frameList = [];            gcontext.GetFrameListRecursive(rootDoc, frameList);        	return frameList;        
    }        
}); // WrapInGlobalContext/////////////////////////////////////////////////////////////////////////////////////////////// This file contains functions that deal with HTML elements.// It is recommended that the code in this file is compatible with all browsers.WrapInGlobalContext(function () {            var gcontext = this;        gcontext.MAX_ATTR_LEN = 64;        // Flag definitions from "<SS_Dir>\Output\COM generated files\UIElement\UIElement_i.h"    // They are used by "ClickHtmlElem".    // Keep in sync!!!    gcontext.UIE_CF_CLICK_MASK = 0x00000003;    gcontext.UIE_CF_SINGLE = 0x00000000;    gcontext.UIE_CF_DOUBLE = 0x00000001;    gcontext.UIE_CF_HOVER = 0x00000002;    gcontext.UIE_CF_BUTTON_MASK = 0x0000000C;    gcontext.UIE_CF_LEFT = 0x00000000;    gcontext.UIE_CF_RIGHT = 0x00000004;    gcontext.UIE_CF_MIDDLE = 0x00000008;    gcontext.UIE_CF_SCREEN_COORDS = 0x00000010;    gcontext.UIE_CF_DOWN = 0x00001000;    gcontext.UIE_CF_UP = 0x00002000;    gcontext.UIE_CF_MOD_CTRL = 0x00004000;    gcontext.UIE_CF_MOD_ALT = 0x00008000;    gcontext.UIE_CF_MOD_SHIFT = 0x00010000;            //Used by "ClickHtmlElement".    gcontext.HTML_LEFT_BUTTON = 0;	// Left button is pressed.     gcontext.HTML_MIDDLE_BUTTON = 1;	// Right button is pressed.     gcontext.HTML_RIGHT_BUTTON = 2;	// Middle button is pressed.        gcontext.HTML_CLICK_SINGLE = 0;	// Simulate Single Click    gcontext.HTML_CLICK_DOUBLE = 1;	// Simulate Double Click    gcontext.HTML_CLICK_HOVERONLY = 2;	// Simulate Mouse Hover only        gcontext.CLICK_OFFSET_X = 2;    gcontext.CLICK_OFFSET_Y = 2;        gcontext.g_getCustomAttrMap = {        	"url": function (elem)        		{        			if (elem.ownerDocument)        				return elem.ownerDocument.URL;        			return "";        
    },    	"htmlwindowname" : function(elem) {        			if (window.name) {            				return window.name;            
        }        			else {            				return "";            
        }        
    },    	"title" : function(elem)    		{        			if (elem.ownerDocument)        				return elem.ownerDocument.title;        			return "";        
    },    	"cookie" : function(elem)    		{        			if (elem.ownerDocument)        				return elem.ownerDocument.cookie;        			return "";        
    },    	"readystate" : function(elem)    		{        			if (elem.ownerDocument)        				return elem.ownerDocument.readyState === "complete" ? "1" : "0";        			return "0";        
    },    	"innertext" : function(elem)    		{        			return gcontext.DeleteForbiddenCharacters(elem.textContent);        
    },        "innertextshort": function (elem)            {                    return gcontext.GetAttributeShortValue(elem, "innertext");        
    },    	"outertext" : function(elem)    		{        			return gcontext.DeleteForbiddenCharacters(elem.textContent);        
    },        "outertextshort": function (elem)            {                    return gcontext.GetAttributeShortValue(elem, "outertext");        
    },    	"innerhtml": function(elem)    		{        			return elem.innerHTML;        
    },        "innerhtmlshort": function (elem)            {                    return gcontext.GetAttributeShortValue(elem, "innerhtml");        
    },    	"outerhtml": function(elem)    		{        			return elem.outerHTML;        
    },        "outerhtmlshort": function (elem)            {                    return gcontext.GetAttributeShortValue(elem, "outerhtml");        
    },    	"tag" : function(elem)    		{        			return elem.tagName;        
    },    	"parentid" : function(elem)    		{        			return gcontext.GetParentAttributeValue(elem, "id");        
    },    	"parentname" : function(elem)    		{        			return gcontext.GetParentAttributeValue(elem, "name");        
    },    	"parentclass" : function(elem)    		{        			return gcontext.GetParentAttributeValue(elem, "class");        
    },    	"tablerow" : function(elem)    		{        	        var r = gcontext.GetTableRowAndCol(elem, { getRow: true }).row;        	        return r < 0 ? "" : r;        
    },    	"tablecol" : function(elem)    		{        	        var c = gcontext.GetTableRowAndCol(elem, { getCol: true }).col;        	        return c < 0 ? "" : c;        
    },    	"rowname" : function(elem) {        			return gcontext.GetTableRowName(elem);        
    },    	"colname" : function(elem) {        			return gcontext.GetTableColName(elem);        
    },    	"columncount" : function(elem) {        			return gcontext.GetTableColCount(elem);        
    },    	"rowcount" : function(elem) {        			return gcontext.GetTableRowCount(elem);        
    },    	"checked" : function(elem)    		{        			if (elem.type !== "checkbox" && elem.type !== "radio")        				return null;        			return elem.checked;        
    },    	"role" : function(elem)    		{        			//TODO: find the role using "instanceOf"        			return "element";        
    },    	"aastate" : function(elem)    		{        			//TODO: extend the possibilities        			if (elem.disabled === true)        				return "disabled";        			return "enabled";        
    },    	"aaname" : function(elem)    		{        			return gcontext.getAccName(elem);        
    },        "aanameshort": function (elem)            {                    return gcontext.GetAttributeShortValue(elem, "aaname");        
    },    	"css-selector" : function (elem)    		{        			return gcontext.getCssSelector(elem);        
    },    	"selecteditem" : function (elem)    		{        			return gcontext.GetSelectedItemTxt(elem);        
    },    	"selecteditems" : function (elem)    		{        			return gcontext.GetSelectedItemsTxt(elem);        
    },    	"isleaf" : function (elem)    		{        			return (gcontext.isLeafElement(elem) ? "1" : "0");        
    }    
};gcontext.GetSelectedItemTxt = function (e) {    	var items = gcontext.GetSelectedItems(e, 0);    	if (items && items.length > 0) {        		return items[0];        
    }        	return "";    
}gcontext.GetSelectedItemsTxt = function (e) {    	var items = gcontext.GetSelectedItems(e, 0);    	var txt = "";        	for (var i = 0; i < items.length; ++i) {        		if (txt) {            			txt = txt + ", ";            
        }                		txt = txt + "\"";        		txt = txt + items[i];        		txt = txt + "\"";        
    }        	txt = "{ " + txt;    	txt = txt + " }";        	return txt;    
}//This function must always return a string.//Boolean values are converted to "0" or "1", the other types are returned as their string representation.gcontext.GetAttributeValue = function (element, attrName){    	var out_attrValue = "";        	var getCustomAttrFunc = gcontext.g_getCustomAttrMap[attrName.toLowerCase()];    	var rawAttrVal;    	if (getCustomAttrFunc != null)    		rawAttrVal = getCustomAttrFunc(element);    	else    		rawAttrVal = element.getAttribute(attrName);        	//Make sure that we return a string    	if (typeof (rawAttrVal) === "boolean")    		out_attrValue = (rawAttrVal ? "1" : "0");    	else if (rawAttrVal != null && rawAttrVal.toString != null)    		out_attrValue = rawAttrVal.toString();        	return out_attrValue;    
}gcontext.GetParentAttributeValue = function (element, attrName){    	var out_attrValue = "";    	var crtElem = element.parentElement;        	while (crtElem != null)    	{        		out_attrValue = gcontext.GetAttributeValue(crtElem, attrName);        		if (out_attrValue.length !== 0)        			break;        		crtElem = crtElem.parentElement;        
    }        	return out_attrValue;    
}gcontext.GetParentByTag = function (element, tagName, requestIntermediateParents, outArgs) {        if (requestIntermediateParents === true && outArgs != null)            outArgs.intermediateParents = [];            var out_parentElem = element.parentElement;            while (out_parentElem != null && out_parentElem.nodeType === out_parentElem.ELEMENT_NODE) {                if (out_parentElem.tagName.toLowerCase() === tagName)                    break;                        if (requestIntermediateParents === true && outArgs != null)                    outArgs.intermediateParents.push(out_parentElem);                        out_parentElem = out_parentElem.parentElement;        
    }            return out_parentElem;    
}gcontext.GetFirstChildText = function (parentElem, tag, index) {    	var children = parentElem.getElementsByTagName(tag);    	if (children == null) {        		return "";        
    }        	if (index > children.length - 1) {        		return "";        
    }        	var text = children.item(index).textContent;    	return gcontext.DeleteForbiddenCharacters(text);    
}gcontext.GetTableRowCount = function (e) {    	var tagName = e.tagName.toLowerCase();    	if (tagName !== "table") {        		return "";        
    }        	var rows = e.getElementsByTagName("tr");    	if (rows !== null) {        		return rows.length.toString();        
    }        	return "";    
}gcontext.GetTableColCount = function (e) {    	var tagName = e.tagName.toLowerCase();    	if (tagName !== "table") {        		return "";        
    }        	var rows = e.getElementsByTagName("tr");    	if ((rows !== null) && (rows.length > 0)) {        		var tds = rows.item(0).getElementsByTagName("td");        		if ((tds !== null) && (tds.length > 0)) {            			return tds.length.toString();            
        }                		var ths = rows.item(0).getElementsByTagName("th");        		if ((ths !== null) && (ths.length > 0)) {            			return ths.length.toString();            
        }        
    }        	return "";    
}gcontext.GetTableRowName = function (elem) {    	var parentRow = gcontext.GetParentByTag(elem, "tr");    	if (!parentRow) {        		return "";        
    }        	var text = gcontext.GetFirstChildText(parentRow, "th", 0);    	if (text === "") {        		text = gcontext.GetFirstChildText(parentRow, "td", 0);        
    }        	return text;    
}gcontext.GetTableColName = function (elem) {    	var table = gcontext.GetParentByTag(elem, "table");    	if (!table) {        		return "";        
    }        	var colIndex = gcontext.GetTableRowAndCol(elem, { getCol: true }).col;    	if (colIndex < 1) {        		return "";        
    }        	var text = gcontext.GetFirstChildText(table, "th", colIndex - 1);    	if (text === "") {        		text = gcontext.GetFirstChildText(table, "td", colIndex - 1);        
    }        	return text;    
}gcontext.GetTableRowAndCol = function (cellElem, inputFlags){    	var out_rowAndCol = { row: -1, col: -1 };    	var tagName = cellElem.tagName.toLowerCase();        	if (tagName !== "td" && tagName !== "th")    	{        		// Not a table cell or table header cell, find a td or th parent.        		var parentCell = gcontext.GetParentByTag(cellElem, "td");        		if (parentCell === null)        		{            			parentCell = gcontext.GetParentByTag(cellElem, "th");            			if (parentCell === null)            			{                				// Cannot get TD/TH parent in GetTableRowAndCol.                				return out_rowAndCol;                
            }            
        }                		cellElem = parentCell;        
    }        	var rowParent = gcontext.GetParentByTag(cellElem, "tr");    	if (rowParent == null)    		return out_rowAndCol;        	if (inputFlags.getCol === true)    		out_rowAndCol.col = gcontext.ComputeIndexInParent(cellElem, rowParent);        	if (inputFlags.getRow === true)    	{        		var tableParent = gcontext.GetParentByTag(rowParent, "table");        		if (tableParent == null)        			return out_rowAndCol;                		out_rowAndCol.row = gcontext.ComputeIndexInParent(rowParent, tableParent);        
    }        	return out_rowAndCol;    
}gcontext.ComputeIndexInParent = function (element, parent){    	var out_index = -1;    	var i;        	var refCustomId = gcontext.GenerateCustomIdForElement(element);        	var children = parent.getElementsByTagName(element.tagName);    	if (children == null)    		return out_index;    	for (i = 0; i < children.length; ++i)    	{                if (gcontext.GetCustomIdForElement(children.item(i)) === refCustomId)        		{            			out_index = i + 1;            			break;            
        }        
    }        	return out_index;    
}gcontext.ElementHasAttributeValues = function (element, attrMap, fuzzyScoreStats){    	if (element == null) {        		return false;        
    }        	var out_match = true;    	for (var attrName in attrMap) {        		// Don't compare css-selector.        		if (attrName !== "css-selector") {            			var crtValue = gcontext.GetAttributeValue(element, attrName);                        //var matchRes = gcontext.StringWildcardMatch(attrMap[attrName], crtValue);                        var caseSensitive = true;                        var matchRes = gcontext.HasAttributeValue(attrMap[attrName]) && attrMap[attrName].Matches(crtValue, caseSensitive, fuzzyScoreStats);            			//gcontext.TraceMessage("ElementHasAttributeValues: matching attribute '"+attrName + "': current value '"+crtValue + "' against given '"+attrMap[attrName]+"' returned " + matchRes);            			if (matchRes === false)            			{                				out_match = false;                				break;                
            }            
        }        
    }        	return out_match;    
}gcontext.FindElementUsingAttributes = function (htmlCollection, index, attrMap) {        var out_element = null;        var i;            if (htmlCollection == null)            return out_element;            var crtIndex = 0;        for (i = 0; i < htmlCollection.length; ++i) {                var crtElem = htmlCollection[i];                if (gcontext.ElementHasAttributeValues(crtElem, attrMap) === true) {                        ++crtIndex;                        if (crtIndex === index) {                                out_element = crtElem;                                break;                
            }            
        }        
    }            return out_element;    
};gcontext.DoubleSummaryStatistics = function () {        this.max = 0.0;        this.min = Number.MAX_VALUE;        this.average = 0;        this.sum = 0;        this.count = 0;            this.accept = function (value) {                gcontext.TraceMessage("DoubleSummaryStatistics: accept " + value);                ++this.count;                        if (value > this.max) this.max = value;                if (value < this.min) this.min = value;                this.sum += value;                this.average = this.sum / this.count;        
    };    
};gcontext.ApproximatelyEqual = function (a, b, epsilon) {        return Math.abs(a - b) <= Math.max(Math.abs(a), Math.abs(b)) * epsilon;    
};gcontext.FindElementCollectionUsingAttributes = function (htmlCollection, attrMap, maxElems) {        var out_elements = [];        var i;            if (htmlCollection == null)            return out_elements;            var crtIndex = 0;        var resultElements = [];            var usingFuzzyAttributes = gcontext.IsUsingFuzzyAttributes(attrMap);        if (usingFuzzyAttributes) {                gcontext.TraceMessage("FindElementCollectionUsingAttributes: using fuzzy attributes");        
    }            for (i = 0; i < htmlCollection.length; ++i) {                var crtElem = htmlCollection[i];                var fuzzyScoreStats = new gcontext.DoubleSummaryStatistics();                        if (gcontext.ElementHasAttributeValues(crtElem, attrMap, fuzzyScoreStats) === true) {                                    if (usingFuzzyAttributes) {                                gcontext.TraceMessage("FindElementCollectionUsingAttributes: fuzzyScoreStats.average =" + fuzzyScoreStats.average);                                var result = { element: crtElem, fuzzyScore: fuzzyScoreStats.average, position: resultElements.length };                                resultElements.push(result);                
            } else {                                out_elements.push(crtElem);                
            }                        if (resultElements.length >= maxElems || out_elements >= maxElems) {                                break;                
            }            
        }        
    }            if (usingFuzzyAttributes) {                var comparator = function (a, b) {                    if (gcontext.ApproximatelyEqual(a.fuzzyScore, b.fuzzyScore, Number.EPSILON)) {                            return a.position - b.position;            
        }                    return b.fuzzyScore - a.fuzzyScore; // descending order        
    };                resultElements.sort(comparator);                for (i = 0; i < resultElements.length; ++i) {                    out_elements.push(resultElements[i].element);        
    }    
}    return out_elements;};gcontext.FindTabCollectionUsingAttributes = function (attrMap, OnFinishedCallback){        var filteredTabs = [];            var OnAllTabsProcessed = function () {            gcontext.TraceMessage("GetMatchingTabs: filteredTabs.length=" + filteredTabs.length);            var comparator = function (a, b) {                if (gcontext.ApproximatelyEqual(a.fuzzyScore, b.fuzzyScore, Number.EPSILON)) {                        return a.position - b.position;        
    }                return b.fuzzyScore - a.fuzzyScore; // descending order    
};        filteredTabs.sort(comparator);        var out_tabs = [];        for (var i = 0; i < filteredTabs.length; ++i) {                out_tabs.push(filteredTabs[i].tabElement);    
}        OnFinishedCallback(out_tabs);    };    var queryOptions = {};  // Empty query options means "get all opened tabs"    chrome.tabs.query(queryOptions, function (tabList) {            var tabCount = tabList ? tabList.length : 0;            if (tabCount == 0) {                    OnAllTabsProcessed();        
    }            else {                    gcontext.TraceMessage("onGetHtmlElemById: tab count = " + tabList.length);                    var ProcessTab = function (tab) {                        gcontext.TraceMessage("onGetHtmlElemById:ProcessTab tab.url = " + tab.url);                                var fuzzyScoreStats = new gcontext.DoubleSummaryStatistics();                        var caseSensitive = true;                                var MatchesSyncAttributes = function (tab) {                            if ((!gcontext.HasAttributeValue(attrMap["title"]) || attrMap["title"].Matches(tab.title, caseSensitive, fuzzyScoreStats))                                && (!gcontext.HasAttributeValue(attrMap["url"]) || attrMap["url"].Matches(tab.url, caseSensitive, fuzzyScoreStats))) {                            return true;    
}                    return false;                };                if (MatchesSyncAttributes(tab)) {                        // At this point, we only need to check async attributes.                        // Currently, that means only "htmlwindowname".                        if (!gcontext.HasAttributeValue(attrMap["htmlwindowname"])) {                                filteredTabs.push({ tabElement: tab, fuzzyScore: fuzzyScoreStats.average, position: filteredTabs.length });                                OnTabProcessed();        
    }                        else if (IsChromeTabUrl(tab.url) ||                            IsFirefoxAboutTabUrl(tab.url)) {                                // We cannot inject code in chrome:// or about:// tabs, so skip processing them.                                gcontext.TraceMessage("onGetHtmlElemById: skipping tab.id: " + tab.id + ", tab.url: " + tab.url);                                        OnTabProcessed();        
    }                        else {                                // window.name is only available in content script.                                 // We execute async script to get it.                                chrome.tabs.executeScript(tab.id, { code: "window.name" },                                        function (result) {                                                var windowName = '' + result; // converts Object to string                                                if (attrMap["htmlwindowname"].Matches(windowName, caseSensitive, fuzzyScoreStats)) {                                                        filteredTabs.push({ tabElement: tab, fuzzyScore: fuzzyScoreStats.average, position: filteredTabs.length });                    
                }                                                OnTabProcessed();                
            });        
    }    
}                else {                        OnTabProcessed();    
}            };            var OnTabProcessed = function () {                --tabCount;                if (tabCount <= 0) {                        OnAllTabsProcessed();    
}            };            for (var i = 0; i < tabList.length; ++i) {                    ProcessTab(tabList[i]);    
}        }    });}//Returns -1 if there was an error or no element was found.//Returns 0 if the element was found and it's unique.//Returns >= 1 if the element was found and it's not unique.gcontext.GetIndexForAttributeList = function (htmlCollection, targetCustomId, attrMap){    	gcontext.TraceMessage("GetIndexForAttributeList: enter targetCustomId=" + targetCustomId);        	var out_index = 0;        	var i = 0;    	var found = false;    	var unique = true;        	for (i = 0; i < htmlCollection.length; ++i)    	{        		var crtElem = htmlCollection[i];                var crtCustomId = gcontext.GetCustomIdForElement(crtElem);        		if (found === false && crtCustomId === targetCustomId)        		{            			gcontext.TraceMessage("GetIndexForAttributeList: element reached");                        			found = true;            			++out_index;            			if (out_index > 1)            			{                				unique = false;                				break;                
            }            
        }        		else if (gcontext.ElementHasAttributeValues(crtElem, attrMap))        		{            			gcontext.TraceMessage("GetIndexForAttributeList: attributes match");                        			if (found)            			{                				unique = false;                				break;                
            }            			else            				++out_index;            
        }        
    }        	if (found === false) {        		out_index = -1;        
    }    	else if (unique === true && out_index === 1) {        		out_index = 0;        
    }        	gcontext.TraceMessage("GetIndexForAttributeList: return index=" + out_index);    	return out_index;    
}gcontext.GetTruncatedAttributeValue = function (targetElement, attrName) {    	var resValue = null;    	var attrVal = gcontext.GetAttributeValue(targetElement, attrName);        	if (attrVal.length !== 0) {        		// Don't truncate css-selector.                resValue = (attrName === "css-selector" ? attrVal : gcontext.TruncateStringUsingWildcard(attrVal, gcontext.MAX_ATTR_LEN));        
    }        	return resValue;    
}gcontext.GetAttributeShortValue = function (element, attrName){        const maxAttrValueLength = 512;        var attrValue = gcontext.GetAttributeValue(element, attrName);        if (attrValue.length > maxAttrValueLength)        {                return gcontext.TruncateStringUsingWildcard(attrValue, maxAttrValueLength);        
    }        return attrValue;    
}gcontext.GetAttrNameShort = function (attrName){        /*     * Some attributes can have very large values (100s of KB).    * The "short" variant of an attribute returns its truncated    * value with "*" appended.    * This improves performance where we don't need the full value.    */        if (attrName === "innertext")        {                return "innertextshort";        
    }        else if (attrName === "outertext")        {                return "outertextshort";        
    }        else if (attrName === "innerhtml")        {                return "innerhtmlshort";        
    }        else if (attrName === "outerhtml")        {                return "outerhtmlshort";        
    }        else if (attrName === "aaname")        {                return "aanameshort";        
    }        return attrName;    
}gcontext.GetSelectorAttributeListResult = function (tagName, attrMap, index, retCode){    	var out_result = {    		tagName: tagName,            attrMap: gcontext.ActiveValueStringMap(attrMap),    		index: index,    		retCode: retCode    
};	return out_result;}gcontext.isLeafElement = function (e) {    	if (!e) {        		return false;        
    }        	return (e.children.length === 0);    
}gcontext.shouldAddAAName = function (e) {    	var t = e.tagName.toLowerCase();    	var acceptedTags = ["a", "label", "img", "input", "button", "textarea", "area", "select", "table", "th"];    	if (acceptedTags.indexOf(t) !== -1) {        		return true;        
    }        	// Use aaname for divs if text length <= 32    	if (((t === "div") || (t === "span")) && (e.textContent.length <= 32)) {        		return true;        
    }        	var acceptedParentTags = ["a", "label", "button", "select", "th"];        	while (true) {        		var p = e.parentElement;        		if (p === null) {            			break;            
        }                		t = p.tagName.toLowerCase();        		if (acceptedParentTags.indexOf(t) !== -1) {            			return true;            
        }                		e = p;        
    }        	return false;    
}gcontext.GetSelectorAttributeList = function (rootDocument, targetCustomId, parentId, targetTagName, computeIndex) {    	gcontext.TraceMessage("GetSelectorAttributeList: enter targetCustomId=[" + targetCustomId + "] parentId=[" + parentId + "] targetTagName=[" + targetTagName + "]");    	if (targetCustomId == null)    	{        		gcontext.TraceMessage("GetSelectorAttributeList: invalid input, return error");        		return gcontext.GetSelectorAttributeListResult("", {}, -1, N_FALSE);        
    }            var getAllDocuments = gcontext.xbrowser.isModeSingleFrame(); // in single frame mode, get all reachable documents        var htmlCollection = gcontext.GetHtmlCollectionForParentId(rootDocument, getAllDocuments, parentId, targetTagName);    	if (htmlCollection == null)    	{        		gcontext.TraceMessage("OnGetHtmlIdInfo: GetHtmlCollectionForParentId('" + parentId + "') failed");                return gcontext.GetSelectorAttributeListResult("", {}, -1, N_FALSE);        
    }        	var targetElement = gcontext.g_customIdCache[targetCustomId];    	if (targetElement == null) {        		gcontext.TraceMessage("GetSelectorAttributeList: targetCustomId=" + targetCustomId + " not found in the cache");                return gcontext.GetSelectorAttributeListResult("", {}, -1, N_FALSE);        
    }        	var attrLists = ["tag", "id", "name", "type", "parentid", "parentname"];        if (gcontext.shouldAddAAName(targetElement)) {        		attrLists.push("aaname");        
    }            if (gcontext.isLeafElement(targetElement)) {        		attrLists.push("isleaf");        
    }        	attrLists.push("css-selector");    	attrLists.push("tabindex");    	attrLists.push("tableRow");    	attrLists.push("tableCol");    	attrLists.push("href");            // for frames, the "src" attribute is more important        // add it after "id" and "name"        if (gcontext.ElementIsFrame(targetElement)) {                attrLists.splice(3, 0, "src");        
    }        else {                attrLists.push("src");        
    }        	// I would not include class attribute because it is mainily used for visual things of the HTML objects    	// and this changes for selected "menu items" for instance.    	//["class", "parentclass"]        	var bestIndex = 1000000;    	if (computeIndex == 0)    	    bestIndex = 0;    	var attrMap = {};        	for (var phaseIdx = 0; phaseIdx < attrLists.length; ++phaseIdx) {        		var crntAttrName = attrLists[phaseIdx];        		var crntAttrValue = gcontext.GetTruncatedAttributeValue(targetElement, crntAttrName);                		if (crntAttrValue) {            			if (crntAttrName === "css-selector" && computeIndex > 0) {                				if (bestIndex <= 1) {                    					// Do not add css-selector if best index is already 1                    					continue;                    
                }                                				// For css-selector we need to recompute htmlCollection.                				var cssSelector = crntAttrValue;                                var getAllDocuments = gcontext.xbrowser.isModeSingleFrame(); // in single frame mode, get all reachable documents                				htmlCollection = gcontext.GetHtmlCollectionForParentId(rootDocument, getAllDocuments, parentId, targetTagName, cssSelector);                				if (htmlCollection === null) {                    					gcontext.TraceMessage("OnGetHtmlIdInfo: GetHtmlCollectionForParentId('" + parentId + "') failed");                                        return gcontext.GetSelectorAttributeListResult("", {}, -1, N_FALSE);                    
                }                
            }                                    attrMap[crntAttrName] = new gcontext.AttributeValue(crntAttrValue);                        			if (computeIndex > 0) {                			    var crntIndex = gcontext.GetIndexForAttributeList(htmlCollection, targetCustomId, attrMap);                                			    //gcontext.TraceMessage("GetSelectorAttributeList: index["+phaseIdx+"]=" + indices[phaseIdx]);                			    if (crntIndex === -1) {                    			        gcontext.TraceMessage("GetSelectorAttributeList: index == -1, return error");                                        return gcontext.GetSelectorAttributeListResult("", {}, -1, N_FALSE);                    
                }                                			    if (crntIndex < bestIndex) {                    			        bestIndex = crntIndex;                    
                }                			    else {                    			        // The current attribute does not decrease the index so don't add it to selector.                    			        delete attrMap[crntAttrName];                    
                }                                			    if (bestIndex === 0) {                    			        //The index was found and the set of attributes uniquely identify the element.                    			        gcontext.TraceMessage("GetSelectorAttributeList: index == 0, return success");                                                            // for frames, having only "tag" is considered too weak because frames determine selector                                        // search scope for other elements and, with "tag" only, the frame selector might match                                        // another element just by adding one more frame to the webpage; try to add one more attribute                                        if (Object.keys(attrMap).length === 1 && gcontext.ElementIsFrame(targetElement)) {                                                var extraAttrList = ["id", "name", "src"];                                                for (var i = 0; i < extraAttrList.length; i += 1) {                                                        var attrName = extraAttrList[i];                                                        var attrValue = gcontext.GetTruncatedAttributeValue(targetElement, attrName);                                                        if (attrValue) {                                                                gcontext.TraceMessage("OnGetHtmlIdInfo: Frame selector has only one attribute. Added extra \"" + attrName + "\"=\"" + attrValue + "\" to make it more precise");                                                                attrMap[attrName] = new gcontext.AttributeValue(attrValue);                                                                break;                                
                            }                            
                        }                                                                        if (Object.keys(attrMap).length === 1) {                                                        gcontext.TraceMessage("OnGetHtmlIdInfo: Warning, frame selector has only \"tag\" attribute and extra attributes could not be added");                            
                        }                        
                    }                                                            return gcontext.GetSelectorAttributeListResult(targetElement.tagName, attrMap, 0, N_TRUE);                    
                }                
            }            
        }        
    }            return gcontext.GetSelectorAttributeListResult(targetElement.tagName, attrMap, bestIndex, N_TRUE);    
}gcontext.GetAttrValueListForElement = function (element, attrExclusionMap) {        function IsAttrExcluded(attrName) {                return attrExclusionMap != null && attrExclusionMap[attrName] != null;        
    }        	var result = {};            if (element !== null) {                var attrNames = gcontext.GetAttributeListForElement(element);                var staticAttrNames =        ["innertext", "outertext", "innerhtml", "outerhtml", "tag", "parentid", "class",                            "parentname", "parentclass", "aaname", "aastate", "role", "cookie", "readystate", "url", "checked", "isleaf", "css-selector",                            "selecteditem", "selecteditems"];                var allAttrNames = staticAttrNames.concat(attrNames);                        for (var n = 0; n < allAttrNames.length; ++n)                {                        var attrName = allAttrNames[n];                        if (attrName !== gcontext.CUSTOM_ID_ATTR_NAME                            && !IsAttrExcluded(attrName))                        {                                var attrNameShort = gcontext.GetAttrNameShort(attrName);                                var crntVal = gcontext.GetAttributeValue(element, attrNameShort);                                if (crntVal !== null && crntVal.length !== 0)                                {                                        result[attrName] = crntVal;                    
                }                
            }            
        }        
    }        else {                // Get the attributes for the page.                if (!IsAttrExcluded("title"))                    result["title"] = document.title;                if (!IsAttrExcluded("url"))                    result["url"] = document.URL;                if (!IsAttrExcluded("cookies"))                    result["cookies"] = document.cookie;                if (!IsAttrExcluded("readystate"))                    result["readystate"] = (document.readyState === "complete" ? "1" : "0");                if (!IsAttrExcluded("text"))                    result["text"] = (document.body ? gcontext.DeleteForbiddenCharacters(document.body.textContent) : "");        
    }        	return result;    
}gcontext.GetAttributeListForElement = function (element){    	var out_attrList = [];        	if (element == null || element.attributes == null)    		return out_attrList;        	var tagName = element.tagName.toLowerCase();        	if ((tagName === "th") || (tagName === "td") ||    	     (gcontext.GetParentByTag(element, "td") !== null) ||    		 (gcontext.GetParentByTag(element, "th") !== null))    	{        		out_attrList.push("tableRow");        		out_attrList.push("tableCol");        		out_attrList.push("rowName");        		out_attrList.push("colName");        
    }        	if (tagName === "table") {        		out_attrList.push("rowCount");        		out_attrList.push("columnCount");        
    }        	for (var i = 0; i < element.attributes.length; ++i)    	{        		var crtAttrName = element.attributes.item(i).nodeName;        		if (crtAttrName != null && crtAttrName.length > 0 &&        			crtAttrName.toLowerCase() !== "checked" &&                    crtAttrName !== gcontext.CUSTOM_ID_ATTR_NAME)        		{            			out_attrList.push(crtAttrName);            
        }        
    }        	return out_attrList;    
}//"parentElem" can be an HTML element or document, they both export the "getElementsByTagName" method.gcontext.GetHtmlCollectionForParentElement = function (parentElem, tagName, cssSelector){    	if (!tagName) {        		tagName = "*";        
    }        	tagName = tagName.toLowerCase();        	var out_collection = [];    	var i;        	var isCssSelectorValid = ((cssSelector !== undefined) && (cssSelector !== null));    	if (isCssSelectorValid)    	{        		try        		{            			var elements = parentElem.querySelectorAll(cssSelector);            			for (i = 0; i < elements.length; ++i) {                				if ((tagName === "*") || (tagName === elements.item(i).tagName.toLowerCase())) {                    					out_collection.push(elements.item(i));                    
                }                
            }            
        }        		catch (e)        		{            			gcontext.TraceMessage("GetHtmlCollectionForParentElement exception: " + e);            			isCssSelectorValid = false;                        out_collection = [];            
        }        
    }        	if (!isCssSelectorValid)    	{        		var elements = parentElem.getElementsByTagName(tagName);        		gcontext.TraceMessage("GetHtmlCollectionForParentElement: getElementsByTagName(tag='" + tagName + "') returned " + elements.length + " elements");                		for (i = 0; i < elements.length; ++i) {            			out_collection.push(elements.item(i));            
        }        
    }        	return out_collection;    
}gcontext.GetHtmlCollectionForParentId = function (rootDocument, getAllDocuments, parentId, tagName, cssSelector){    	gcontext.TraceMessage("GetHtmlCollectionForParentId: enter parentId=" + parentId + " tagName=" + tagName);        	var i;    	var out_collection = [];        	if (parentId != null && parentId.length > 0)    	{        		var parentElem = gcontext.g_customIdCache[parentId];        		if (parentElem == null)        		{            			gcontext.TraceMessage("GetHtmlCollectionForParentId: parentId=" + parentId + " not found in the cache");            			return null;            
        }        		out_collection = gcontext.GetHtmlCollectionForParentElement(parentElem, tagName, cssSelector);        
    }    	else        {                // to support legacy selectors, search elements through all allowed documents                var docs = [rootDocument];                if (getAllDocuments && gcontext.IsMainFrame(window)) {                        docs = gcontext.GetDocumentList(rootDocument);            
        }                		//gcontext.TraceMessage("GetHtmlCollectionForParentId: docs.length="+docs.length);        		for (i = 0; i < docs.length; ++i)                    out_collection = out_collection.concat(gcontext.GetHtmlCollectionForParentElement(docs[i], tagName, cssSelector));        		if (out_collection.length === 0)        			out_collection = null;        
    }        	gcontext.TraceMessage("GetHtmlCollectionForParentId: return");    	return out_collection;    
}gcontext.GetDirectChildrenCollectionForParentElement = function (parentElem, tagName){    	var i;    	var out_collection = [];    	for (i = 0; i < parentElem.children.length; ++i)    	{        		var crtElem = parentElem.children.item(i);        		if (tagName == null || tagName.length === 0 ||        			crtElem.tagName.toLowerCase() === tagName        			)        			out_collection.push(crtElem);        
    }    	return out_collection;    
}gcontext.GetDirectChildrenCollectionForParentId = function (rootDocument, getAllDocuments, parentId, tagName){    	gcontext.TraceMessage("GetDirectChildrenCollectionForParentId: enter tagName=[" + tagName + "]");        	var i;    	var out_collection = [];        	if (parentId != null && parentId.length > 0)    	{        		var parentElem = gcontext.g_customIdCache[parentId];        		if (parentElem == null)        		{            			gcontext.TraceMessage("GetDirectChildrenCollectionForParentId: parentId=" + parentId + " not found in the cache");            			return null;            
        }                		gcontext.TraceMessage("GetDirectChildrenCollectionForParentId: calling GetDirectChildrenCollectionForParentElement on parentId");                out_collection = gcontext.GetDirectChildrenCollectionForParentElement(parentElem, tagName);        
    }    	else        {                // to support legacy selectors, search elements through all allowed documents                gcontext.TraceMessage("GetDirectChildrenCollectionForParentId: calling GetDirectChildrenCollectionForParentElement on each doc");                var docs = [rootDocument];                if (getAllDocuments) {                        docs = gcontext.GetDocumentList(rootDocument);            
        }                		for (i = 0; i < docs.length; ++i)        		{            			var docElem = docs[i].documentElement;            			if (docElem.tagName.toLowerCase() === tagName)            				out_collection.push(docElem);                        out_collection = out_collection.concat(gcontext.GetDirectChildrenCollectionForParentElement(docElem, tagName));            
        }        		if (out_collection.length === 0)        			out_collection = null;        
    }        	gcontext.TraceMessage("GetDirectChildrenCollectionForParentId: return");    	return out_collection;    
}gcontext.GetFrameParent = function (rootDoc, frameElement){    	var out_frameParent = null;    	var customIdToSearch = gcontext.GenerateCustomIdForElement(frameElement);    	var frames = gcontext.GetFrameList(rootDoc);    	var frameIdx = 0;        	//gcontext.TraceMessage("GetFrameParent: frameElement.src=" + frameElement.src);    	//gcontext.TraceMessage("GetFrameParent: frameElement.tagName=" + frameElement.tagName);    	//gcontext.TraceMessage("GetFrameParent: frames.length=" + frames.length);    	//gcontext.TraceMessage("GetFrameParent: customIdToSearch=" + customIdToSearch);    	for (frameIdx = 0; frameIdx < frames.length && out_frameParent == null; ++frameIdx)    	{        		var crtFrame = frames[frameIdx];        		var crtDoc = gcontext.GetSafeContentDocument(crtFrame);        		if (crtDoc)        		{            			var children = crtDoc.getElementsByTagName(frameElement.tagName);            			//gcontext.TraceMessage("GetFrameParent: children.length="+children.length);                        			var childIdx = 0;            			for (childIdx = 0; childIdx < children.length; ++childIdx)            			{                				var crtElem = children.item(childIdx);                                var crtCustomId = gcontext.GetCustomIdForElement(crtElem);                				//gcontext.TraceMessage("GetFrameParent: crtElem.src="+crtElem.src + " crtCustomId="+crtCustomId);                				if (crtCustomId === customIdToSearch)                				{                    					out_frameParent = crtFrame;                    					break;                    
                }                
            }            
        }        
    }        	return out_frameParent;    
}gcontext.GetElementClientBoundingCssRectangle = function (rootDoc, element) {        var htmlRc = element.getBoundingClientRect();        var out_rc = gcontext.UiRect(htmlRc.left, htmlRc.top, htmlRc.width, htmlRc.height);            if (gcontext.IsMainFrame(window)) {                var parent = gcontext.GetFrameParent(rootDoc, element);                while (parent) {                        htmlRc = parent.getBoundingClientRect();                        gcontext.TraceMessage("GetElementClientCssRectangle: offsetting with (" + htmlRc.left, htmlRc.top + ")");                        out_rc = out_rc.Offset(htmlRc.left, htmlRc.top);                        parent = gcontext.GetFrameParent(rootDoc, parent);            
        }        
    }            return out_rc;            return gcontext.UiRect(htmlRc.left, htmlRc.top, htmlRc.width, htmlRc.height);    
}gcontext.GetElementClientInnerCssRectangle = function (element) {        var htmlRc = element.getBoundingClientRect();            return gcontext.UiRect(htmlRc.left + element.clientLeft,                          htmlRc.top + element.clientTop,                          element.clientWidth,                          element.clientHeight);    
}//This function only applies to "select" elementsgcontext.GetTextFromSelection = function (selectElement){    	var out_text = "";        	//gcontext.TraceMessage("GetTextFromSelection: selectElement size="+selectElement.size + " multiple="+selectElement.multiple);    	if (selectElement.size <= 1 && selectElement.multiple === false)    	{        		if (selectElement.selectedIndex === -1)        			return out_text;        		out_text = selectElement.item(selectElement.selectedIndex).text;        
    }        	return out_text;    
}//This function only applies to "select" elementsgcontext.GetFullTextFromSelect = function (selectElement){    	var out_text = "";        	var i;    	var options = selectElement.getElementsByTagName("option");    	//gcontext.TraceMessage("GetFullTextFromSelect: options.length=" + options.length);    	for (i = 0; i < options.length; ++i)    	{        		var option = options.item(i);        		if (option.text && option.text.length > 0)        			out_text += option.text + "\n";        
    }        	return out_text;    
}gcontext.GetTextContentFromElement = function (element){    	var out_text = "";        	var tag = element.tagName.toLowerCase();    	if (tag === "select")            out_text = gcontext.GetTextFromSelection(element);    	else    		out_text = gcontext.TrimWhiteSpaces(element.textContent);        	return out_text;    
}gcontext.GetIntCssProperty = function (style, propName, unitSuffix, defaultValue){    	var out_intValue = defaultValue;    	var propValue = style.getPropertyValue(propName);    	//gcontext.TraceMessage("GetIntCssProperty: " + propName + "=["+propValue+"]");    	if (propValue != null && propValue.length > 0)    	{        		if (propValue.length > unitSuffix.length &&        			propValue.slice(propValue.length - unitSuffix.length) === unitSuffix        			)        		{            			var numericPart = propValue.slice(0, propValue.length - unitSuffix.length);            			//gcontext.TraceMessage("GetIntCssProperty: parsing [" + numericPart + "]");            			out_intValue = parseInt(numericPart);            
        }        
    }        	return out_intValue;    
}//Returns the total margin of a parent with the same client rectangle as the given element. This margin will be used as a margin//for the original element when the browser formats the text.gcontext.GetElementMarginFromParent = function (htmlWindow, element){    	var out_marginSize = 0;        	if (element == null || element.parentNode == null)    		return out_marginSize;        	var elementRect = element.getBoundingClientRect();    	//gcontext.TraceMessage("GetElementMarginFromParent: elementRect width=" + elementRect.width + " height = " + elementRect.height);    	for (var ancestor = element.parentNode;    		ancestor != null && ancestor.nodeType === ancestor.ELEMENT_NODE;    		ancestor = ancestor.parentNode)    	{        		var ancestorRect = ancestor.getBoundingClientRect();        		//gcontext.TraceMessage("GetElementMarginFromParent: ancestorRect width=" + ancestorRect.width + " height = " + ancestorRect.height);        		if (ancestorRect.width > elementRect.width && ancestorRect.height > elementRect.height)        			break;                		if (ancestorRect.width === elementRect.width && ancestorRect.height === elementRect.height)        		{            			var style = htmlWindow.getComputedStyle(ancestor);                        var borderSize = gcontext.GetIntCssProperty(style, "margin-left", "px", 0) +            							 gcontext.GetIntCssProperty(style, "margin-right", "px", 0);            			//gcontext.TraceMessage("GetElementMarginFromParent: borderSize=" + borderSize);                        			if (borderSize > out_marginSize)            				out_marginSize = borderSize;            
        }        
    }        	return out_marginSize;    
}gcontext.TextRectInfo = function (text, rect, lineWidth, endsWithWhitespace){    	return {        		text: text,        		rect: rect,        		lineWidth: lineWidth, //The width of the line to which this text belongs to.        		endsWithWhitespace: endsWithWhitespace        
    };    
}gcontext.CreateTextExtractorObject = function (htmlWindow, rootDocument, element, separators){    	//These output parameters accumulate with each call to AccumulateRectInfoFromElement.    	var out_textRectInfos = [];            	////////////////////////////////////    	// Private variables    	var LINE_OVERFLOW_TOLERANCE = 1;    	var m_spanElem = null;    	var m_elemRect = null;    	var m_elemCustomId = "", m_parentElemCustomId = "";    	var m_srcStyle = null;    	var m_borderLeft = 0, m_borderTop = 0, m_borderRight = 0;    	var m_initialOffsetForSpacing = { x: 0, y: 0 };    	var m_crtOffsetForSpacing = { x: 0, y: 0 };    	var m_maxLineRight = 0;    	var m_lineWidth = 0, m_lineHeight = 0;    	var m_totalTextHeight = 0;            	////////////////////////////////////////    	// Private methods        	//Input: local 'm_spanElem', arg 'word'    	//Output: {width, height}    	//Calculates the dimensions of a word with no leading or trailing white spaces.    	function GetNonWhitespaceWordExtentsUsingSpan(word)    	{        		m_spanElem.textContent = word;        		var rc = m_spanElem.getBoundingClientRect();        		return { width: rc.width, height: rc.height };        
    }        	var DUMMY_BORDER_CHAR = "x";    	var m_dummyBorderCharWidth = 0;    	//Input: local 'm_spanElem'    	//Output: local 'm_dummyBorderCharWidth'    	//Caches the width of the dummy border character "x" to be used with words starting or ending in white spaces.    	function GetDummyBorderCharWidth()    	{        		if (m_dummyBorderCharWidth !== 0)        			return m_dummyBorderCharWidth;        		//Use a dummy character for calculating the extents of words with heading or trailing white spaces.        		m_dummyBorderCharWidth = GetNonWhitespaceWordExtentsUsingSpan(DUMMY_BORDER_CHAR).width;        		return m_dummyBorderCharWidth;        
    }    	//Input: local 'm_spanElem', arg 'word'    	//Output: {width, height}    	//Calculates the dimensions of a word with possible leading or trailing whitespaces.    	function GetWordExtentsUsingSpan(word)    	{        		if (word.length === 0)        			return { width: 0, height: 0 };                		var extraHeading = "";        		var extraTrailing = "";        		var extraHeadingWidth = 0;        		var extraTrailingWidth = 0;                if (gcontext.IsWhiteSpaceCharacter(word.charAt(0)))        		{            			extraHeading = DUMMY_BORDER_CHAR;            			extraHeadingWidth = GetDummyBorderCharWidth();            
        }                if (gcontext.IsWhiteSpaceCharacter(word.charAt(word.length - 1)))        		{            			extraTrailing = DUMMY_BORDER_CHAR;            			extraTrailingWidth = GetDummyBorderCharWidth();            
        }                		var wordExt = GetNonWhitespaceWordExtentsUsingSpan(extraHeading + word + extraTrailing);                		return { width: wordExt.width - extraHeadingWidth - extraTrailingWidth, height: wordExt.height };        
    }        	////////////////////////////////////////////    	// The main object with the public methods    	return {        		BeginAccumulateTextRectInfo: function ()        		{        			//Input validation        			if (element == null)        				return false;                			var doc = element.ownerDocument;        			m_srcStyle = htmlWindow.getComputedStyle(element);        			m_spanElem = doc.createElement("span");        			var cssProps = [        				//"font",         				"font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight",        				"text-align", "text-align-last", "text-decoration", "text-indent", "text-justify", "text-overflow", "text-shadow",        					"text-transform", "text-autospace", "text-kashida-space", "text-underline-position",        				//"padding", "border",        				"direction", "zoom"        			];        			for (i = 0; i < cssProps.length; ++i)        			{            				var propName = cssProps[i];            				var propValue = m_srcStyle.getPropertyValue(propName);            				if (propValue != null && propValue.length > 0)            				{                					var propPriority = m_srcStyle.getPropertyPriority(propName);                					m_spanElem.style.setProperty(propName, propValue, propPriority);                					//gcontext.TraceMessage("GetTextRectInfoFromElement: setting ["+propName+"]=["+propValue + "] priority "+propPriority);                
            }            
        }        			m_spanElem.style.setProperty("resize", "both", "");        			m_spanElem.style.setProperty("display", "inline-block", "");        			//Add the SPAN element to the DOM.        			doc.body.appendChild(m_spanElem);                			//Some variables for parsing the text.        			m_borderLeft = //(element.clientLeft ? element.clientLeft : GetIntCssProperty(m_srcStyle, "border-left-width", "px", 0)) +         							 gcontext.GetIntCssProperty(m_srcStyle, "padding-left", "px", 0);        							 //GetIntCssProperty(m_srcStyle, "margin-left", "px", 0);        			m_borderTop = //(element.clientTop ? element.clientTop : GetIntCssProperty(m_srcStyle, "border-top-width", "px", 0)) +         							gcontext.GetIntCssProperty(m_srcStyle, "padding-top", "px", 0);        							//GetIntCssProperty(m_srcStyle, "margin-top", "px", 0);        			m_borderRight = //(element.clientRight ? element.clientRight : GetIntCssProperty(m_srcStyle, "border-right-width", "px", 0)) +         							  gcontext.GetIntCssProperty(m_srcStyle, "padding-right", "px", 0);        							  //GetIntCssProperty(m_srcStyle, "margin-right", "px", 0);                    m_elemRect = gcontext.GetElementClientBoundingCssRectangle(rootDocument, element);        			m_elemCustomId = gcontext.GenerateCustomIdForElement(element);        			m_parentElemCustomId = gcontext.GenerateCustomIdForElement(element.parentNode);                			m_initialOffsetForSpacing.x = m_elemRect.left + m_borderLeft;        			m_initialOffsetForSpacing.y = m_elemRect.top + m_borderTop;        			m_maxLineRight = m_elemRect.right - m_borderRight;                			//Update the current offset for text spacing.        			m_crtOffsetForSpacing.x = m_initialOffsetForSpacing.x;        			m_crtOffsetForSpacing.y = m_initialOffsetForSpacing.y;                			//The line width is the width of the HTML element without its border.        			m_lineWidth = (m_elemRect.right - m_borderRight) - (m_elemRect.left + m_borderLeft);                			//Parse the line height from the CSS style of the source element.                    m_lineHeight = gcontext.GetIntCssProperty(m_srcStyle, "line-height", "px", 0);                			//Initialize the total text height.        			m_totalTextHeight = m_lineHeight;                			gcontext.TraceMessage("BeginAccumulateTextRectInfo: m_lineHeight=" + m_lineHeight);        			gcontext.TraceMessage("BeginAccumulateTextRectInfo: m_maxLineRight=" + m_maxLineRight);                    gcontext.TraceMessage("BeginAccumulateTextRectInfo: m_initialOffsetForSpacing=" + gcontext.EnumObjectProps(m_initialOffsetForSpacing, true));        			gcontext.TraceMessage("BeginAccumulateTextRectInfo: m_elemRect=" + m_elemRect.toString());        			gcontext.TraceMessage("BeginAccumulateTextRectInfo: border LTR = (" + m_borderLeft + " " + m_borderTop + " " + m_borderRight + ")");                			return true;        
    },        		EndAccumulateTextRectInfo: function()    		{        			//Apply the alignment correction as found in the CSS style of the source element.        			if (m_srcStyle != null)        			{            				var i = 0;            				var borderTopCorrection = 0;            				var verticalAlign = m_srcStyle.getPropertyValue("vertical-align");            				if (verticalAlign === "middle")            				{                					//"middle" centers the text in the current element.                					var centeredBorderTop = (m_elemRect.getHeight() - m_totalTextHeight) / 2;                					gcontext.TraceMessage("GetTextBorderTopCorrectionFromCss: totalTextHeight=" + m_totalTextHeight + " centeredBorderTop=" + centeredBorderTop);                					borderTopCorrection = centeredBorderTop - m_borderTop;                
            }            				else if (verticalAlign === "baseline" || verticalAlign === "bottom")            				{                					//"baseline" and "bottom" align the text with the bottom of the current element.                					var bottomAlignedBorderTop = m_elemRect.getHeight() - m_totalTextHeight;                					gcontext.TraceMessage("GetTextBorderTopCorrectionFromCss: totalTextHeight=" + m_totalTextHeight + " bottomAlignedBorderTop=" + bottomAlignedBorderTop);                					borderTopCorrection = bottomAlignedBorderTop - m_borderTop;                
            }                        				if (borderTopCorrection !== 0)            				{                					for (i = 0; i < out_textRectInfos.length; ++i)                						out_textRectInfos[i].rect = out_textRectInfos[i].rect.Offset(0, borderTopCorrection);                
            }            
        }                			//The last word ends with space, we do not want automatic formatting with another element.        			if (out_textRectInfos.length !== 0)        				out_textRectInfos[out_textRectInfos.length - 1].endsWithWhitespace = true;                			//Remove the auxiliary span element.        			if (m_spanElem != null)        			{            				element.ownerDocument.body.removeChild(m_spanElem);            				m_spanElem = null;            
        }                			gcontext.TraceMessage("EndAccumulateTextRectInfo: return");        			return out_textRectInfos;        
    },        		AdvanceTextOffsets: function(advanceX)    		{        			var newOffsetX = m_crtOffsetForSpacing.x + advanceX;        			var lineOverflow = newOffsetX - m_maxLineRight;        			if (lineOverflow >= LINE_OVERFLOW_TOLERANCE)        			{            				//Line overflow, move the offset to a new line.            				m_crtOffsetForSpacing.x = m_initialOffsetForSpacing.x;            				m_crtOffsetForSpacing.y += m_lineHeight;            				//Update the total text height.            				m_totalTextHeight += m_lineHeight;            
        }        			else        				m_crtOffsetForSpacing.x = newOffsetX;        
    },        		AccumulateTextRectInfo: function(text)    		{        			///////////////////////////        			// Input validation        			if (text == null || text.length === 0)        				return false;        			if (m_spanElem == null)        				return false;                        			//////////////////////////////////        			// Private local variables        			var m_crtWordForSpacing = "", m_crtWord = "";                        			//////////////////////////////////        			// Private local methods                			var CharType = { WORD: 0, SEPARATOR: 1, WHITESPACE: 2 };        			//Input: local arg 'separators'        			//Output: CharType        			function GetCharType(ch)        			{                            if (gcontext.IsWhiteSpaceCharacter(ch))            					return CharType.WHITESPACE;            				if (separators.indexOf(ch) !== -1)            					return CharType.SEPARATOR;            				return CharType.WORD;            
        }                            // Test if a Point belongs to a Rectangle's surface                    function RectContains(rect, point) {                            return ((point.x >= rect.left && point.x < rect.right) &&                                    (point.y >= rect.top && point.y < rect.bottom));            
        }                			//Input: local 'm_spanElem', local 'm_crtWordForSpacing', local 'm_elemRect'        			//Output: local 'm_crtOffsetForSpacing', local 'm_crtWordForSpacing', return 'wordExtents'        			//Checks the extents of the existing 'm_crtWordForSpacing' against the width of the HTML element.        			//If the width is exceeded, then a new line is simulated by advancing the Y offset.        			//The X offset for the current word is optionally updated.        			function CheckNewLineAndUpdateSpacingOffsets()        			{            				//Get the word dimensions.            				var out_wordExtForSpacing = GetWordExtentsUsingSpan(m_crtWordForSpacing);            				//Check if theline height obtained from the CSS properties is correct.            				if (m_lineHeight === 0 && out_wordExtForSpacing.height > m_lineHeight)            				{                					m_lineHeight = out_wordExtForSpacing.height;                					m_totalTextHeight = m_lineHeight;                					gcontext.TraceMessage("AccumulateTextRectInfo::CheckNewLineAndUpdateSpacingOffsets: m_lineHeight=" + m_lineHeight);                
            }            				//Move the current offset such that it does not overlap with any other HTML element.            				//Also, it must not overflow the width of the rectangle of the current HTML element.            				var wordExt = GetWordExtentsUsingSpan(m_crtWord);            				var checkOverlappingElements = true;                        				// Early detect that overlapping is not possible if the current word is smaller than the tolerance.            				// Also, please note that the algorithm below, which moves the current offset to skip            				// overlapping elements, will enter an infinite loop if it runs over an empty word.            				// The current offset will not advance and will always hit the same overlapping element.            				var INNER_TOLERANCE = 2;            				if (wordExt.width < (2 * INNER_TOLERANCE) || wordExt.height < (2 * INNER_TOLERANCE)) {                					checkOverlappingElements = false;                
            }                        				while (checkOverlappingElements === true)            				{                					checkOverlappingElements = false;                                					//Check any overlapping HTML elements.                					if (m_crtWord.length > 0)// && IsWhiteSpaceCharacter(m_crtWord.charAt(0)) === false)                					{                    						var points = [                    							{
                        x: m_crtOffsetForSpacing.x + wordExt.width / 2,                        							  y: m_crtOffsetForSpacing.y + wordExt.height / 2,                        							  name: "middle"
                    },                    							{
                        x: m_crtOffsetForSpacing.x + INNER_TOLERANCE,                        							  y: m_crtOffsetForSpacing.y + INNER_TOLERANCE,                        							  name: "left-top"
                    },                    							{
                        x: m_crtOffsetForSpacing.x + wordExt.width - INNER_TOLERANCE,                        							  y: m_crtOffsetForSpacing.y + INNER_TOLERANCE,                        							  name: "right-top"
                    },                    							{
                        x: m_crtOffsetForSpacing.x + INNER_TOLERANCE,                        							  y: m_crtOffsetForSpacing.y + wordExt.height - INNER_TOLERANCE,                        							  name: "left-bottom"
                    },                    							{
                        x: m_crtOffsetForSpacing.x + wordExt.width - INNER_TOLERANCE,                        							  y: m_crtOffsetForSpacing.y + wordExt.height - INNER_TOLERANCE,                        							  name: "right-bottom"
                    }                    						];                    						for (var i = 0; i < points.length; ++i)                    						{                        							var crtPoint = points[i];                        							if (crtPoint.x <= m_maxLineRight)                        							{                            								var elemAtPoint = element.ownerDocument.elementFromPoint(crtPoint.x, crtPoint.y);                            								if (elemAtPoint != null)                            								{                                									var htmlRectAtPoint = elemAtPoint.getBoundingClientRect();                                                                    var customIdAtPoint = gcontext.GetCustomIdForElement(elemAtPoint);                                									if (htmlRectAtPoint != null &&                                										htmlRectAtPoint.left > -5 && htmlRectAtPoint.top > -5 &&                                										htmlRectAtPoint.width > 0 && htmlRectAtPoint.height > 0 &&                                                                        // workaround for a Firefox bug: under certain scenarios,                                                                        // document.elementFromPoint() returns an element which doesn't actually contain the point                                                                        RectContains(htmlRectAtPoint, crtPoint) &&                                										customIdAtPoint !== m_elemCustomId &&                                										customIdAtPoint !== m_parentElemCustomId)                                									{                                                                            var spacingGapX = gcontext.GetElementMarginFromParent(htmlWindow, elemAtPoint);                                    										gcontext.TraceMessage("AccumulateTextRectInfo::CheckNewLineAndUpdateSpacingOffsets: crtWord=[" + m_crtWord +                                        											"]: there is an element with tag [" + elemAtPoint.tagName +                                        											"]");// text [" + TruncateStringUsingWildcard(elemAtPoint.textContent,20) +                                     											//"] at location "+EnumObjectProps(crtPoint,true));                                    										//Another element is at this location. Skip it.                                    										m_crtOffsetForSpacing.x = htmlRectAtPoint.right + spacingGapX;                                    										//We are overlapping, check again at the next cycle.                                    										checkOverlappingElements = true;                                    										break;                                    
                                }                                
                            }                            
                        }                        
                    }                    
                }                					//Check if the current rectangle overflows the width of the HTML rectangle of the current element.                					var lineOverflow = (m_crtOffsetForSpacing.x + wordExt.width) - m_maxLineRight;                					if (lineOverflow >= LINE_OVERFLOW_TOLERANCE)                					{                    						gcontext.TraceMessage("AccumulateTextRectInfo::CheckNewLineAndUpdateSpacingOffsets: [" + m_crtWord +                        							"] overflows the right margin by " + lineOverflow + " pixels");                    						//Line overflow, move the offset to a new line.                    						m_crtOffsetForSpacing.x = m_initialOffsetForSpacing.x;                    						m_crtOffsetForSpacing.y += m_lineHeight;                    						gcontext.TraceMessage("AccumulateTextRectInfo::CheckNewLineAndUpdateSpacingOffsets: m_crtOffsetForSpacing after correction " +                                                    gcontext.EnumObjectProps(m_crtOffsetForSpacing, true));                    						//Update the total text height.                    						m_totalTextHeight += m_lineHeight;                    						//We cannot append new lines indefinitely.                    						if (m_crtOffsetForSpacing.y >= m_elemRect.bottom)                    						{                        							gcontext.TraceMessage("AccumulateTextRectInfo::CheckNewLineAndUpdateSpacingOffsets: m_crtOffsetForSpacing.y=" + m_crtOffsetForSpacing.y +                            								" overflows the bottom side " + m_elemRect.bottom + " of the element rectangle");                        							break;                        
                    }                    						//Check if the current word overlaps with another element.                    						checkOverlappingElements = true;                    
                }                
            }                        				return out_wordExtForSpacing;            
        }                        			//////////////////////////////////        			// The main algorithm                			//Make sure we have some separators.        			if (separators == null || separators.length === 0)        				separators = "`;:'\",.!?/\\|";                			var i = 0;                			//Some variables for parsing the text.        			var parserState = CharType.WORD;//GetCharType(text[0]);        			var crtXOffsetInWord = 0;                			for (i = 0; i < text.length; ++i)        			{            				var ch = text.charAt(i);            				var chType = GetCharType(ch);                        				if (parserState === CharType.WORD)            				{                					//A word is forming.                					if (chType === CharType.SEPARATOR || chType === CharType.WHITESPACE)                					{                    						if (m_crtWord.length > 0)                    						{                        							//Separator encountered, add the accumulated word to the list.                        							//At this moment, "m_crtWord == m_crtWordForSpacing", so there is no need to calculate the extents                        							//of 'm_crtWord'.                        							var wordExt = CheckNewLineAndUpdateSpacingOffsets();                        							//Add the current word and its rectangle                        							var wordInfo = gcontext.TextRectInfo(                        								m_crtWord,                                                        gcontext.UiRect(m_crtOffsetForSpacing.x, m_crtOffsetForSpacing.y, wordExt.width, wordExt.height),                        								m_lineWidth,                        								chType === CharType.WHITESPACE                        							);                        							out_textRectInfos.push(wordInfo);                        							gcontext.TraceMessage("AccumulateTextRectInfo: adding word [" + wordInfo.text +                            								"] rect " + wordInfo.rect.toString());                        							//Leave the current word for spacing calculation (m_crtOffsetForSpacing).                        							m_crtWordForSpacing += ch;                        							m_crtWord = ch.toString();                        							crtXOffsetInWord = wordExt.width;//For separators                        							parserState = chType;                        
                    }                    						else                    						{                        							//Empty word, reset the operational words and change the parser state.                        							m_crtWordForSpacing = m_crtWord = ch.toString();                        							crtXOffsetInWord = 0;                        							parserState = chType;                        
                    }                    
                }                					else //if(chType === CharType.WORD)                					{                    						//Not a separator or whitespace, accumulate the current word.                    						m_crtWordForSpacing += ch;                    						m_crtWord += ch;                    
                }                
            }            				else if (parserState === CharType.SEPARATOR)            				{                					//We are inside a separator portion.                					if (chType === CharType.WORD || chType === CharType.WHITESPACE)                					{                    						var spacingExt = CheckNewLineAndUpdateSpacingOffsets();                    						//Add the current separator as a word.				                    						var wordExt = GetWordExtentsUsingSpan(m_crtWord);                    						var wordInfo = gcontext.TextRectInfo(                    							m_crtWord,                                                gcontext.UiRect(m_crtOffsetForSpacing.x + crtXOffsetInWord, m_crtOffsetForSpacing.y, wordExt.width, wordExt.height),                    							m_lineWidth,                    							chType === CharType.WHITESPACE                    						);                    						out_textRectInfos.push(wordInfo);                    						//gcontext.TraceMessage("AccumulateTextRectInfo: adding word ["+wordInfo.text +                     						//	"] rect ("+wordInfo.rect.left+" "+wordInfo.rect.top+" "+wordInfo.rect.getWidth()+" "+wordInfo.rect.getHeight()+")");                    						//A word is starting all over again.                    						m_crtWordForSpacing = m_crtWord = ch.toString();                    						m_crtOffsetForSpacing.x += spacingExt.width;                    						crtXOffsetInWord = 0;                    						parserState = chType;                    
                }                					else //if(chType === CharType.SEPARATOR)                					{                    						//Add the current separator as a word.                    						CheckNewLineAndUpdateSpacingOffsets();                    						var wordExt = GetWordExtentsUsingSpan(m_crtWord);                                            var wordInfo = gcontext.TextRectInfo(                    							m_crtWord,                                                gcontext.UiRect(m_crtOffsetForSpacing.x + crtXOffsetInWord, m_crtOffsetForSpacing.y, wordExt.width, wordExt.height),                    							m_lineWidth,                    							false                    						);                    						out_textRectInfos.push(wordInfo);                    						//gcontext.TraceMessage("AccumulateTextRectInfo: adding word ["+wordInfo.text +                     						//	"] rect ("+wordInfo.rect.left+" "+wordInfo.rect.top+" "+wordInfo.rect.getWidth()+" "+wordInfo.rect.getHeight()+")");                    						//Accumulate the current word for spacing.                    						m_crtWordForSpacing += ch;                    						m_crtWord = ch.toString();                    						crtXOffsetInWord += wordExt.width;                    
                }                
            }            				else if (parserState === CharType.WHITESPACE)            				{                					if (chType === CharType.WORD || chType === CharType.SEPARATOR)                					{                    						//Advance the current word.                    						var spacingExt = CheckNewLineAndUpdateSpacingOffsets();                    						//A word is starting all over again.                    						m_crtWordForSpacing = m_crtWord = ch.toString();                    						m_crtOffsetForSpacing.x += spacingExt.width;                    						crtXOffsetInWord = 0;                    						parserState = chType;                    
                }                					else //if(chType === CharType.WHITESPACE)                					{                    						//Check if a new line has been reached.                    						CheckNewLineAndUpdateSpacingOffsets();                    						//Accumulate the whitespace.                    						m_crtWordForSpacing += ch;                    						m_crtWord = "";                    						crtXOffsetInWord = 0;                    
                }                
            }            
        }                			//gcontext.TraceMessage("AccumulateTextRectInfo: last word ["+m_crtWord+"]");                			//Record the last word.        			var spacingExt = CheckNewLineAndUpdateSpacingOffsets();        			if (parserState !== CharType.WHITESPACE && m_crtWord.length > 0)        			{            				var wordExt = GetWordExtentsUsingSpan(m_crtWord);                            var wordInfo = gcontext.TextRectInfo(            					m_crtWord,                                gcontext.UiRect(m_crtOffsetForSpacing.x + crtXOffsetInWord, m_crtOffsetForSpacing.y, wordExt.width, wordExt.height),            					m_lineWidth,            					false            				);            				out_textRectInfos.push(wordInfo);            				gcontext.TraceMessage("AccumulateTextRectInfo: adding last word [" + wordInfo.text +                					"] rect " + wordInfo.rect.toString());            
        }        			//Update the spacing offsets.        			m_crtOffsetForSpacing.x += spacingExt.width;                			return true;        
    }    
}}gcontext.FormattedTextInfoResult = function (){    	function TextLine(lineWidth)    	{        		return {            			textInfos: [],            			lineWidth: lineWidth,            			AddTextInfo: function (textInfo)            			{            				this.textInfos.push(textInfo);            
        },        			AddTextInfoArray: function(textInfoArray)        			{            				this.textInfos = this.textInfos.concat(textInfoArray);            
        },        			PushTextInfosAtTheStart: function(additionalTextInfos)        			{            				var out_overflowingWordsAtTheEnd = [];                        				if (additionalTextInfos.length === 0 || this.textInfos.length === 0)            					return out_overflowingWordsAtTheEnd;                        				gcontext.TraceMessage("PushTextInfosAtTheStart: additionalTextInfos[0]=" + additionalTextInfos[0].text);            				gcontext.TraceMessage("PushTextInfosAtTheStart: this.textInfos[0]=" + this.textInfos[0].text);                        				//Calculate the total shift width.            				var i = 0;            				var totalWidth = additionalTextInfos[0].rect.getWidth();            				for (i = 1; i < additionalTextInfos.length; ++i)            					totalWidth += additionalTextInfos[i].rect.getWidth();            				gcontext.TraceMessage("PushTextInfosAtTheStart: totalWidth=" + totalWidth);            				//Shift the current text rectangles.            				var startTrimIdx = -1;            				for (i = 0; i < this.textInfos.length; ++i)            				{                					this.textInfos[i].rect = this.textInfos[i].rect.Offset(totalWidth, 0);                					if (this.textInfos[i].rect.right - this.textInfos[0].rect.left > lineWidth)                					{                    						startTrimIdx = i;                    						break;                    
                }                
            }            				//Check overlapping rectangles.            				/*for(i=0; i<this.textInfos.length-1; ++i)				{					var crtInfo = this.textInfos[i];					var nextInfo = this.textInfos[i+1];					if(crtInfo.rect.right > nextInfo.rect.left)					{						var correctedCrtInfo = TextRectInfo(							nextInfo.text,							UiRect(nextInfo.rect.left - totalWidth, nextInfo.rect.top, nextInfo.rect.getWidth(), nextInfo.rect.getHeight()),							lineWidth,							nextInfo.endsWithWhitespace						);												nextInfo.text = crtInfo.text;						nextInfo.rect = UiRect(correctedCrtInfo.rect.left + correctedCrtInfo.rect.getWidth(),						                       correctedCrtInfo.rect.top,											   crtInfo.rect.getWidth(), crtInfo.rect.getHeight());						nextInfo.lineWidth = lineWidth;						nextInfo.endsWithWhitespace = crtInfo.endsWithWhitespace;												crtInfo = correctedCrtInfo;					}				}*/            				//Remove the overflowing text infos at the end.            				if (startTrimIdx !== -1)            					out_overflowingWordsAtTheEnd = this.textInfos.splice(startTrimIdx, this.textInfos.length - startTrimIdx);            				//Add the new text infos at the start.            				this.textInfos = additionalTextInfos.concat(this.textInfos);                        				return out_overflowingWordsAtTheEnd;            
        }        
    };    
}	return {    		lines: [],    		AddLine: function (lineWidth)    		{    			this.lines.push(TextLine(lineWidth));    
},		AddTextInfo: function(textInfo)		{    			if (this.lines.length === 0)    				return;    			this.lines[this.lines.length - 1].AddTextInfo(textInfo);    
},		AddTextInfoArray: function(textInfoArray)		{    			if (this.lines.length === 0)    				return;    			this.lines[this.lines.length - 1].AddTextInfoArray(textInfoArray);    
},		ShiftTextInfosAndReformat: function(lineIdxToShift, numWordsToShift)		{    			if (lineIdxToShift >= this.lines.length || numWordsToShift <= 0)    				return;        			var line = this.lines[lineIdxToShift];    			if (numWordsToShift > line.textInfos.length)    				return;        			var wordsToShift = line.textInfos.splice(line.textInfos.length - numWordsToShift, numWordsToShift);        			var i = 0, j = 0;    			for (i = lineIdxToShift + 1; i < this.lines.length; ++i)    			{        				line = this.lines[i];        				//Shift the rectangles of the current words.        				if (line.textInfos.length !== 0)        				{            					var shiftWidth = -(wordsToShift[0].rect.left - line.textInfos[0].rect.left);            					var shiftHeight = -(wordsToShift[0].rect.top - line.textInfos[0].rect.top);            					gcontext.TraceMessage("ShiftTextInfosAndReformat: shiftWidth=" + shiftWidth + " shiftHeight=" + shiftHeight);            					for (j = 0; j < wordsToShift.length; ++j)            						wordsToShift[j].rect = wordsToShift[j].rect.Offset(shiftWidth, shiftHeight);            
        }        				//Add them to the start of this line and get the remaining ones.        				wordsToShift = line.PushTextInfosAtTheStart(wordsToShift);        				if (wordsToShift.length === 0)        					break;        
    }    			if (wordsToShift.length !== 0)    			{        				line = this.lines[this.lines.length - 1];        				//Shift the rectangles of the current words.        				if (line.textInfos.length !== 0)        				{            					var shiftWidth = -(wordsToShift[0].left - line.textInfos[0].left);            					var shiftHeight = -(wordsToShift[0].top - line.textInfos[0].top);            					for (j = 0; j < wordsToShift.length; ++j)            						wordsToShift[j].rect = wordsToShift[j].rect.Offset(shiftWidth, shiftHeight);            
        }        				//Create a new line.        				this.AddLine(line.lineWidth);        				this.AddTextInfoArray(wordsToShift);        
    }    
},		GetFilteredText: function(filterRect)		{    			var out_text = "";    			var out_textRectInfo = [];        			var lineIdx = 0;    			for (lineIdx = 0; lineIdx < this.lines.length; ++lineIdx)    			{        				var crtLine = this.lines[lineIdx];        				var textInfoIdx = 0;        				for (textInfoIdx = 0; textInfoIdx < crtLine.textInfos.length; ++textInfoIdx)        				{            					textInfo = crtLine.textInfos[textInfoIdx];            					if (filterRect.Intersects(textInfo.rect))            					{                						out_textRectInfo.push(textInfo);                                						out_text += textInfo.text;                						if (textInfo.endsWithWhitespace)                							out_text += " ";                
            }            
        }        				if (lineIdx !== this.lines.length - 1)        					out_text += "\r\n";        
    }        			return { text: out_text, textRectInfo: out_textRectInfo };    
}	};}//Reformats the text given by the TextExtractor object.//If a line ends in a separator and there is no white space after, the word will be moved on the next line.gcontext.FormatTextRectInfoArray = function (textRectInfo, newLineTolerance, runStopwatch){    	var out_formattedTextInfo = gcontext.FormattedTextInfoResult();        	//Sort all the rectangles.    	textRectInfo.sort(        		function (e1, e2)        		{            			var rc1 = e1.rect;            			var rc2 = e2.rect;            			if(rc1.top >= rc2.bottom - newLineTolerance)    				return 1;    			if (rc2.top >= rc1.bottom - newLineTolerance)    				return -1;    			if (rc1.left >= rc2.right - newLineTolerance)    				return 1;    			if (rc2.left >= rc1.right - newLineTolerance)    				return -1;    			return 0;    
}	);    // check for timeout once for a certain number of expensive operations    // to limit the performance impact of timeout checks    var timeoutCheckCounter = 0;	//Make all the words on the same line have the same line width.	var i = 0, j = 0, startLineIdx = 0;	while (startLineIdx < textRectInfo.length)	{            if (timeoutCheckCounter >= 300) {                    if (runStopwatch.TimeoutElapsed())                        break;                    timeoutCheckCounter = 0;        
    }        		var startLineInfo = textRectInfo[startLineIdx];    		//Compute the maximum line width for this line.    		var maxLineWidth = startLineInfo.lineWidth;    		var endLineIdx = startLineIdx + 1;    		while (endLineIdx < textRectInfo.length)    		{        			var endLineInfo = textRectInfo[endLineIdx];        			if (endLineInfo.rect.top >= startLineInfo.rect.bottom - newLineTolerance)        				break;                			if (endLineInfo.lineWidth > maxLineWidth)        				maxLineWidth = endLineInfo.lineWidth;                			++endLineIdx;        
    }    		//Add these lines as formatted text.    		out_formattedTextInfo.AddLine(maxLineWidth);    		for (i = startLineIdx; i < endLineIdx; ++i)    		{        			var srcTextInfo = textRectInfo[i];                    var destTextInfo = gcontext.TextRectInfo(srcTextInfo.text, srcTextInfo.rect,        				maxLineWidth,        				srcTextInfo.endsWithWhitespace);                            timeoutCheckCounter += 1;        			out_formattedTextInfo.AddTextInfo(destTextInfo);        
    }        		startLineIdx = endLineIdx;    
}	//With each line, check the word at the end. If it does not end in a whitespace, move it to the next line.	for (i = 0; i < out_formattedTextInfo.lines.length - 1; ++i)	{            if (timeoutCheckCounter >= 100) {                    if (runStopwatch.TimeoutElapsed())                        break;                    timeoutCheckCounter = 0;        
    }        		var crtLine = out_formattedTextInfo.lines[i];    		//var nextLine = out_formattedTextInfo.lines[i+1];        		if (crtLine.textInfos.length !== 0)    		{        			//Get the last text with whitespace from the current line.        			var lastTextWithSpaceIdx = crtLine.textInfos.length - 1;        			while (lastTextWithSpaceIdx >= 0)        			{            				if (crtLine.textInfos[lastTextWithSpaceIdx].endsWithWhitespace === true)            					break;            				--lastTextWithSpaceIdx;            
        }        			if (lastTextWithSpaceIdx >= 0 && lastTextWithSpaceIdx < crtLine.textInfos.length - 1)        			{            				//Move all the linked text from the current line to the next line.            				var numWordsToShift = crtLine.textInfos.length - lastTextWithSpaceIdx - 1;            				gcontext.TraceMessage("FormatTextRectInfoArray: starting to shift with word [" + crtLine.textInfos[lastTextWithSpaceIdx + 1].text + "]");                            timeoutCheckCounter += 1;            				out_formattedTextInfo.ShiftTextInfosAndReformat(i, numWordsToShift);            
        }        
    }    
}	return out_formattedTextInfo;}//This function only applies to "select" elementsgcontext.GetSelectedItems = function (selectElement, getAll){    	// typeof(getAll) is "number"    	getAll = (getAll !== 0);        	var out_selectedItems = [];    	var options = selectElement.getElementsByTagName("option");    	//gcontext.TraceMessage("GetFullTextFromSelect: options.length=" + options.length);        	for (var i = 0; i < options.length; ++i)    	{        		var option = options.item(i);        		if (option.text && option.text.length > 0)        		{            			if (getAll === true || (getAll === false && option.selected))            			{                				out_selectedItems.push(option.text);                
            }            
        }        
    }        	return out_selectedItems;    
}//This function only applies to "select" elementsgcontext.SelectMultipleItems = function (selectElement, itemsToSelect){    	var i;    	var options = selectElement.getElementsByTagName("option");    	//gcontext.TraceMessage("GetFullTextFromSelect: options.length=" + options.length);    	for (i = 0; i < options.length; ++i)    	{        		var option = options.item(i);        		if (option.text && option.text.length > 0)        			option.selected = (itemsToSelect.indexOf(option.text) !== -1);        
    }    
}//This function only applies to "select" elementsgcontext.GetSelectItemIndex = function (selectElement, itemText){    	//gcontext.TraceMessage("GetFullTextFromSelect: enter itemText=" + itemText);        	var out_itemIndex = -1;        	if (selectElement == null || itemText == null || itemText.length === 0)    	{        		//gcontext.TraceMessage("GetFullTextFromSelect: invalid input, return -1");        		return out_itemIndex;        
    }        	var i;    	var options = selectElement.getElementsByTagName("option");    	//gcontext.TraceMessage("GetFullTextFromSelect: options.length=" + options.length);    	for (i = 0; i < options.length; ++i)    	{        		var option = options.item(i);        		//gcontext.TraceMessage("GetFullTextFromSelect: options["+i+"]=" + option.text);        		if (gcontext.StringWildcardMatch(itemText, option.text))        		{            			out_itemIndex = i;            			break;            
        }        
    }        	//gcontext.TraceMessage("GetFullTextFromSelect: return index="+out_itemIndex);    	return out_itemIndex;    
}gcontext.SelectSingleItem = function (selectElement, itemToSelect){    	var itemIndex = gcontext.GetSelectItemIndex(selectElement, itemToSelect);    	if (itemIndex === -1)    	{        		// Item not found.        		return false;        
    }        	if (selectElement.selectedIndex !== itemIndex) {        		selectElement.selectedIndex = itemIndex;        
    }        	return true;    
}gcontext.AddHiddenSpansForInputValues = function (htmlDoc){    	var out_addedNodes = [];    	var i;        	var collection = htmlDoc.getElementsByTagName("input");    	for (i = 0; i < collection.length; ++i)    	{        		var elem = collection.item(i);        		var type = elem.type;        		var value = elem.value;        		if (type !== "hidden" && type !== "checkbox" && type !== "radio" && type !== "image" &&        			value != null)        		{            			var tempElem = htmlDoc.createElement("span");            			tempElem.innerText = value;            			if (tempElem.style)            				tempElem.style.display = "none";            			if (elem.parentNode)            			{                				var newNode = elem.parentNode.insertBefore(tempElem, elem);                				if (newNode)                					out_addedNodes.push(newNode);                
            }            
        }        
    }        	collection = htmlDoc.getElementsByTagName("textarea");    	for (i = 0; i < collection.length; ++i)    	{        		var elem = collection.item(i);        		var type = elem.type;        		var value = elem.value;        		if (value != null)        		{            			var tempElem = htmlDoc.createElement("span");            			tempElem.innerText = value;            			if (tempElem.style)            				tempElem.style.display = "none";            			if (elem.parentNode)            			{                				var newNode = elem.parentNode.insertBefore(tempElem, elem);                				if (newNode)                					out_addedNodes.push(newNode);                
            }            
        }        
    }        	return out_addedNodes;    
}//The string can contain characters as long as modifiers".//Example: "<ctrl>c</ctrl>xyz".//The modifiers are specified like this: "<ctrl>" - Ctrl on//                                       "</ctrl>" - Ctrl off//                                       "<alt>" - Alt on//                                       "</alt>" - Alt off//                                       "<shift>" - Shift on//                                       "</shift>" - Shift offgcontext.SendKeysToHtmlElement = function (targetElement, htmlWindow, text, setValue, append){    	//Set the keyboard focus.        gcontext.RaiseUiEvent(targetElement, "focus", htmlWindow);    	//Send the specified characters as keyboard events.    	//Use a parser with 2 states: "character" and "modifier".    	var ParserState = {    		CHARACTER: 0,    		MODIFIER: 1    
};	var crtState = ParserState.CHARACTER;	var crtToken = "", textNoModifiers = "";	var ctrlOn = false, altOn = false, shiftOn = false;	var setModifiersMap = {		"<ctrl>": function() { ctrlOn = true; },		"</ctrl>": function() { ctrlOn = false; },		"<alt>": function() { altOn = true; },		"</alt>": function() { altOn = false; },		"<shift>": function() { shiftOn = true; },		"</shift>": function() { shiftOn = false; }	}	var i = 0;	for (i = 0; i < text.length; ++i)	{    		var crtChar = text.charAt(i);        		if (crtState === ParserState.CHARACTER)    		{        			if (crtChar === '<')        				crtState = ParserState.MODIFIER;        			crtToken = crtChar;        
    }    		else    		{        			//"Modifier" state.        			if (crtChar === '>')        				crtState = ParserState.CHARACTER;        			crtToken += crtChar;        
    }        		if (crtToken.length !== 0)    		{        			if (crtToken.length === 1)        			{            				if (crtState === ParserState.CHARACTER)            				{                					var crtCharCode = text.charCodeAt(i);                                    if (gcontext.RaiseKeyEvent(targetElement, "keydown", htmlWindow, crtCharCode, crtCharCode, ctrlOn, altOn, shiftOn, text[i]))                					{                                            gcontext.RaiseKeyEvent(targetElement, "keypress", htmlWindow, crtCharCode, crtCharCode, ctrlOn, altOn, shiftOn, text[i]);                    						//Add this character to the text value to be assigned as the "value" attribute.                    						if (setValue === true && ctrlOn === false && altOn === false)                    							textNoModifiers += crtChar;                    
                }                                    gcontext.RaiseKeyEvent(targetElement, "keyup", htmlWindow, 0, crtCharCode, ctrlOn, altOn, shiftOn, text[i]);                
            }            
        }        			else        			{            				var setModifiers = setModifiersMap[crtToken.toLowerCase()];            				if (setModifiers)            					setModifiers();            
        }        
    }    
}	if ((textNoModifiers !== "") && (setValue === true || targetElement.value != null))	{    		if (append)    			targetElement.value = targetElement.value + textNoModifiers;    		else    			targetElement.value = textNoModifiers;    		//Notify all listeners that the value has changed            gcontext.RaiseUiEvent(targetElement, "input", htmlWindow);            gcontext.RaiseUiEvent(targetElement, "change", htmlWindow);    
}	//Move the focus away now that the text has been written.	//RaiseUiEvent(targetElement, "blur", htmlWindow);}gcontext.RaiseClickEvent = function (element, view, button, clickType,    	screenX, screenY, clientX, clientY,    	ctrlOn, altOn, shiftOn){    	if (view == null || element == null)    		return false;        	var doc = element.ownerDocument;    	if (doc == null)    		return false;        	// right button click is a particular case which opens the context menu    	var types = null;    	if (button == 2 && clickType == gcontext.HTML_CLICK_SINGLE)    	{                types = ["mouseover", "mousemove", "mousedown", "mouseup", "contextmenu"];        
    }    	else    	{                types = (clickType == gcontext.HTML_CLICK_DOUBLE ? ["mouseover", "mousemove", "mousedown", "mouseup", "click", "mousedown", "mouseup", "click", "dblclick"] :        				 clickType == gcontext.HTML_CLICK_HOVERONLY ? ["mouseover", "mouseenter", "mousemove"] :        ["mouseover", "mousemove", "mousedown", "mouseup", "click"]);		// default: HTML_CLICK_SINGLE        
    }        	var canBubble = true;    	var cancelable = true;    	var detail = 1;//Number of clicks.    	var relatedTarget = null;        	for (var i = 0; i < types.length; ++i)        {                try {                                    var event = doc.createEvent("MouseEvents");                        if (event == null)                            return false;                        event.uiPathSimulatedEvent = true;//This prevents the event monitor from processing this event.                        event.initMouseEvent(types[i], canBubble, cancelable, view, detail,                                screenX, screenY, clientX, clientY,                                ctrlOn, altOn, shiftOn, false,                                button, relatedTarget);                                    element.dispatchEvent(event);            
        }                catch (err) {                        gcontext.TraceMessage("RaiseClickEvent exception: " + err.message);            
        }        
    }        	return true;    
}// returns: Boolean value (true: we should consider that the event was not filtered, false: the event was filtered)gcontext.RaiseKeyEvent = function (element, type, view, keyCode, charCode, ctrlOn, altOn, shiftOn, charStr){    	if (view == null || element == null)    	{        		// This mimics the behaviour of older Driver versions.        		// (the return value of RaiseKeyEvent was previously ignored)        		return true;        
    }        	var canBubble = true;    	var cancelable = true;            try {                var doc = element.ownerDocument;                if (doc == null)                    return false;                        var event = doc.createEvent("KeyboardEvent");                if (event == null)                    return false;                        gcontext.InitKeyboardEvent(event, type, canBubble, cancelable, view,                        keyCode, charCode, ctrlOn, altOn, shiftOn);                        event.uiPathSimulatedEvent = true;//This prevents the event monitor from processing this event.                        return element.dispatchEvent(event);        
    }        catch (err) {                gcontext.TraceMessage("RaiseKeyEvent exception: " + err.message);                return false;        
    }    
}gcontext.RaiseUiEvent = function (element, type, view){    	if (view == null || element == null)    		return false;        	var doc = element.ownerDocument;    	if (doc == null)    		return false;        	var canBubble = true;    	var cancelable = false;    	var detail = 1;        	var event = doc.createEvent("UIEvents");    	if (event == null)    		return false;            try {                event.uiPathSimulatedEvent = true;//This prevents the event monitor from processing this event.                event.initUIEvent(type, canBubble, cancelable, view, detail);                        element.dispatchEvent(event);        
    }        catch (err) {                gcontext.TraceMessage("RaiseUiEvent exception: " + err.message);        
    }        	return true;    
}gcontext.getCssSelector = function (e) {    	var cssSel = "";        	while (true) {        		var t = e.tagName.toLowerCase();                        // escape special characters                t = t.replace(/:/g, "\\:");     // ':' = pseudo-class specifier, appears in custom Tags declared in CSS namespaces                		if (cssSel === "") {            			cssSel = t;            
        }        		else {            			cssSel = t + ">" + cssSel;            
        }                		if (t === "body") {            			break;            
        }                		var p = e.parentElement;        		if (p === null) {            			break;            
        }                		e = p;        
    }        	return cssSel;    
}gcontext.ElementIsFrame = function (e) {        var out_isFrame = N_FALSE;            if (e && e.tagName) {                var tagName = e.tagName.toLowerCase();                if (tagName === "frame" || tagName === "iframe")                    out_isFrame = N_TRUE;        
    }            return out_isFrame;    
}gcontext.IsMainFrame = function (frameWindow) {        return (frameWindow.parent === frameWindow || frameWindow.parent === null);    
}}); // WrapInGlobalContextWrapInGlobalContext(function () {            var gcontext = this;        gcontext.MATCHRES_SUCCESS = 0;    gcontext.MATCHRES_INFERIOR_HIERARCHY = 1;    gcontext.MATCHRES_SUPERIOR_HIERARCHY = 2;    gcontext.MATCHRES_FAIL = 3;        gcontext.MatchAttributesInXmlNode = function (htmlElem, xmlNode)    {            //gcontext.TraceMessage("MatchAttributesInXmlNode: enter htmlElem="+htmlElem + " xmlNode="+xmlNode);        	if (htmlElem == null || xmlNode == null || xmlNode.nodeType !== xmlNode.ELEMENT_NODE)        	{            		//gcontext.TraceMessage("MatchAttributesInXmlNode: not an XML element, return MATCHRES_FAIL");            		return false;            
        }                	var xmlTag = xmlNode.tagName.toLowerCase();        	//gcontext.TraceMessage("MatchAttributesInXmlNode: xmlTag="+xmlTag);                	if (xmlTag === "html")        	{            		var htmlTag = htmlElem.tagName.toLowerCase();            		if (htmlTag !== "html")            		{                			//The XML is not describing an HTML element.                			//Any HTML tag is inferior to the "HTML" tag.                			//gcontext.TraceMessage("MatchAttributesInXmlNode: return MATCHRES_INFERIOR_HIERARCHY");                            return gcontext.MATCHRES_INFERIOR_HIERARCHY;                
            }            
        }            else if (xmlTag !== "webctrl")            {                    //The XML is not describing an HTML element.                    //HTML is inferior to WND.            		//gcontext.TraceMessage("MatchAttributesInXmlNode: return MATCHRES_INFERIOR_HIERARCHY");                    return gcontext.MATCHRES_INFERIOR_HIERARCHY;            
        }                    // Get the collection of attributes.        	var attributeList = xmlNode.attributes;        	if (attributeList == null)        	{            		//gcontext.TraceMessage("MatchAttributesInXmlNode: attributeList == null, return MATCHRES_FAIL");                    return gcontext.MATCHRES_FAIL;            
        }                	// Browse the list.        	var i = 0;        	for (i = 0; i < attributeList.length; ++i)        	{            		//gcontext.TraceMessage("MatchAttributesInXmlNode: processing attributeList["+i+"]");            		// Get the i-th item in the list.            		var currentAttrNode = attributeList.item(i);            		// Get the name of the attribute.            		var attrName = currentAttrNode.nodeName;            		if (attrName == null || attrName.length === 0)            		{                			//gcontext.TraceMessage("MatchAttributesInXmlNode: attrName == null, return MATCHRES_FAIL");                            return gcontext.MATCHRES_FAIL;                
            }            		attrName = attrName.toLowerCase();            		if (attrName === "idx" || attrName === "app")            		{                			// Skip the index or app attributes, we do not need them for matching.                			//gcontext.TraceMessage("MatchAttributesInXmlNode: skipping 'idx' or 'app' attribute");                			continue;                
            }            		//gcontext.TraceMessage("MatchAttributesInXmlNode: attrName="+attrName);                        		// Get the value of the attribute.            		var attrValue = currentAttrNode.value;            		if (attrValue == null || attrValue.length === 0)            		{                			//gcontext.TraceMessage("MatchAttributesInXmlNode: attrValue == null, return MATCHRES_FAIL");                            return gcontext.MATCHRES_FAIL;                
            }            		//gcontext.TraceMessage("MatchAttributesInXmlNode: attrValue="+attrValue);                        		//See if this XML attribute is present in the HTML attribute list.                    var htmlAttrValue = gcontext.GetAttributeValue(htmlElem, attrName);            		//gcontext.TraceMessage("MatchAttributesInXmlNode: htmlAttrValue="+htmlAttrValue);            		if (htmlAttrValue.length === 0)            		{                            //gcontext.TraceMessage("MatchAttributesInXmlNode: htmlAttrValue is empty, return MATCHRES_FAIL");                            return gcontext.MATCHRES_FAIL;                
            }                    if (gcontext.StringWildcardMatch(attrValue, htmlAttrValue) === false)            		{                            //gcontext.TraceMessage("MatchAttributesInXmlNode: attributes do not match, return MATCHRES_FAIL");                            return gcontext.MATCHRES_FAIL;                
            }            
        }                    //gcontext.TraceMessage("MatchAttributesInXmlNode: return MATCHRES_SUCCESS");            return gcontext.MATCHRES_SUCCESS;        
    }        gcontext.ComputeIndexUsingXmlNode = function (rootDocument, htmlElem, xmlNode, htmlAncestor)    {        	//gcontext.TraceMessage("ComputeIndexUsingXmlNode: enter");                	if (htmlElem == null || xmlNode == null || xmlNode.nodeType !== xmlNode.ELEMENT_NODE)        	{            		//gcontext.TraceMessage("ComputeIndexUsingXmlNode: invalid args, return -1");            		return -1;            
        }                	// The XML node must describe an HTML UIElement.            var xmlTag = xmlNode.tagName.toLowerCase();        	//gcontext.TraceMessage("ComputeIndexUsingXmlNode: xmlTag="+xmlTag);            if (xmlTag !== "webctrl")            {                    // The XML is not describing an HTML element.            		//gcontext.TraceMessage("ComputeIndexUsingXmlNode: xmlTag != webctrl, return 0");                    return -1;            
        }                    // Decide the parent objects for calculating the index.        	var htmlTag = htmlElem.tagName.toLowerCase();        	var elemId = gcontext.GenerateCustomIdForElement(htmlElem);        	var parentId = (htmlAncestor ? gcontext.GenerateCustomIdForElement(htmlAncestor) : null);            var htmlCollection = gcontext.GetHtmlCollectionForParentId(rootDocument, true, parentId, htmlTag);                    // Get the attributes from XML.        	var xmlAttributeList = xmlNode.attributes;            var i = 0;            var attrMap = {};        	for (i = 0; i < xmlAttributeList.length; ++i)        	{            		// Get the i-th item in the list.            		var attrNode = xmlAttributeList.item(i);            		var attrName = attrNode.nodeName;            		if (attrName === "tag" || attrName === "idx")            			continue;            		var attrValue = attrNode.value;                                attrMap[attrName] = new gcontext.AttributeValue(attrValue);            		gcontext.TraceMessage("ComputeIndexUsingXmlNode: pushing attribute '" + attrName + "'=[" + attrValue + "]");            
        }                    // Calculate the index.            var out_index = gcontext.GetIndexForAttributeList(htmlCollection, elemId, attrMap);        	//gcontext.TraceMessage("ComputeIndexUsingXmlNode: return out_index="+out_index);        	return out_index;        
    }        gcontext.MatchSelector = function (rootDocument, htmlElem, selector, matchChildren)    {        	//gcontext.TraceMessage("MatchSelector: enter");                	if (window.DOMParser == null || htmlElem == null || selector == null)        	{            		//gcontext.TraceMessage("MatchSelector: invalid args, return false");            		return false;            
        }                	//Load the XML selector into an XML Document object.        	var xmlParser = new DOMParser();        	var xmlDoc = xmlParser.parseFromString("<root>" + selector + "</root>", "text/xml");                	//Check if the selector belongs to Chrome.        	var crtXmlNode = xmlDoc.documentElement.firstChild;        	if (crtXmlNode == null || crtXmlNode.nodeType !== crtXmlNode.ELEMENT_NODE)        	{            		//gcontext.TraceMessage("MatchSelector: invalid first child, return false");            		return false;            
        }        	var tagName = crtXmlNode.tagName.toLowerCase();        	if (tagName !== "html" && crtXmlNode.getAttribute("app") !== "chrome.exe")        	{            		//gcontext.TraceMessage("MatchSelector: not a Chrome HTML selector, return false");            		return false;            
        }                	//Local function used to filter element type nodes.        	function SearchXmlElementInPreviousSiblings(xmlNode)        	{            		var out_xmlNode = xmlNode;            		while (out_xmlNode && out_xmlNode.nodeType !== out_xmlNode.ELEMENT_NODE)            			out_xmlNode = out_xmlNode.previousSibling;            		return out_xmlNode;            
        }                    //Build a list of matching nodes and elements.            var out_retCode = false;            var nodeList = [];            var crtHtmlElem = htmlElem;            var xmlNodeSwitch = false;                    //Start iterating the XML nodes in reverse direction and the UIElements from parent to parent.            //Add parents that match the currently iterated XML node.            //When the UIElem does not match the XMLNode, switch the XMLNode to its parent to try it on the new UIElem.            //Add the UIElem parents as long as they match the current XMLNode.        	crtXmlNode = SearchXmlElementInPreviousSiblings(xmlDoc.documentElement.lastChild);        	if (crtXmlNode == null)        	{            		//gcontext.TraceMessage("MatchSelector: invalid last child, return false");            		return false;            
        }                    nodeList.push({ xmlNode: crtXmlNode, matchingElements: [] });            while (crtXmlNode && crtHtmlElem && crtHtmlElem.nodeType === crtHtmlElem.ELEMENT_NODE)            {                    var matchRes = gcontext.MatchAttributesInXmlNode(crtHtmlElem, crtXmlNode);            		//gcontext.TraceMessage("MatchSelector: matchRes="+matchRes);                    if (matchRes === gcontext.MATCHRES_SUCCESS)            		{                			//The current element has the right attributes. Add it into the current list head (head of the parent stack).                			nodeList[0].matchingElements.push(crtHtmlElem);                                			//Switch the UIElem to its parent.                			crtHtmlElem = crtHtmlElem.parentNode;                                			//Check if the INDEX attribute in the XML exists and is positive.                			//INDEX=0 or NULL means that the element is unique.                			var indexAttr = crtXmlNode.getAttribute("idx");                			if (indexAttr == null || indexAttr === "" || indexAttr === "0")                			{                    				//Switch the XMLNode to the previous node for unique elements.                    				crtXmlNode = SearchXmlElementInPreviousSiblings(crtXmlNode.previousSibling);                    				if (crtXmlNode)                    				{                        					//Add a new list head for the newly iterated XMLNode.                        					nodeList.unshift({ xmlNode: crtXmlNode, matchingElements: [] });                        					xmlNodeSwitch = true;                        
                    }                    
                }                			else                				//The UIElem is already switched to its parent in this iteration.                				//Switch the XMLNode to its parent at the next iteration in case of attribute mismatch.                				bmlNodeSwitch = false;                
            }            		else            		{                			//Attributes do not match                			if (xmlNodeSwitch === false)                			{                    				if (nodeList[0].matchingElements.length === 0)                    				{                        					if (matchChildren)                        					{                            						//No matching elements, we are still looking for the first matching node.                            						//If the selector can match any child of the indicated element, navigate the current UIElem to its                            						//parent in order to ignore the current non-matching child and consider it "matching".                            						crtHtmlElem = crtHtmlElem.parentNode;                            
                        }                        					else                        					{                            						//No matching elements, we have not found the first, child-most matching node.                            						//In this case, the selector does not exactly match.                            						//gcontext.TraceMessage("MatchSelector: the inner-most child was not found, return false");                            						return false;                            
                        }                        
                    }                    				else                    				{                        					//The XMLNode has not been switched to its parent at the last attribute match, but the UIElem was.                        					//In this iteration, we have an attribute mismatch.                        					//Move from 'node_n' to 'node_(n-1)', maybe the next XML parent will match the current UIElem.                        					crtXmlNode = SearchXmlElementInPreviousSiblings(crtXmlNode.previousSibling);                        					if (crtXmlNode)                        					{                            						//Add a new list head for the newly iterated XMLNode.                            						nodeList.unshift({ xmlNode: crtXmlNode, matchingElements: [] });                            						//XMLNode has been switched. The next iteration mismatch will switch the UIElem to its parent.                            						xmlNodeSwitch = true;                            
                        }                        
                    }                    
                }                			else                			{                    				//If the current UIElem is on a higher hierarchy than the XMLNode, there is no point in continuing.                    				//REMARK: this will never happen, the curent UiElem can only be WEBCTRL.                    				//if(matchRes === MATCHRES_SUPERIOR_HIERARCHY)                    					//return false;                    				//The last operation switched the current XMLNode. Now switch the UIElem.                    				crtHtmlElem = crtHtmlElem.parentNode;                    
                }                
            }            
        }                	//gcontext.TraceMessage("MatchSelector: nodeList.length="+nodeList.length);                    //Now check the index of each node info element.            var ancestorHtmlElem = null;        	var i = 0, j = 0;        	for (i = 0; i < nodeList.length; ++i)            {                    var matchInfo = nodeList[i];            		//gcontext.TraceMessage("MatchSelector: processing index for nodeList["+i+"]");                    if (matchInfo.matchingElements.length === 0)            		{                            //gcontext.TraceMessage("MatchSelector: no matching elements, return false");                			return false;                
            }                                var xmlIndexAttr = matchInfo.xmlNode.getAttribute("idx");                    var xmlIndex = (xmlIndexAttr ? parseInt(xmlIndexAttr) : 0);            		//gcontext.TraceMessage("MatchSelector: xmlIndex="+xmlIndex);                    if (xmlIndex !== 0)                    {                            //The current XMLNode describes an element which is not unique.                            //Calculate the index attribute of each matching UIElem.                            for (j = 0; j < matchInfo.matchingElements.length; ++j)                            {                                    //The index calculation requires an ancestor.                                    var htmlIndex = gcontext.ComputeIndexUsingXmlNode(rootDocument, matchInfo.matchingElements[j], matchInfo.xmlNode, ancestorHtmlElem);                    				//gcontext.TraceMessage("MatchSelector: htmlIndex="+htmlIndex);                                    if (htmlIndex === xmlIndex)                    				{                                            //The element with matching index attribute is found.                                            //gcontext.TraceMessage("MatchSelector: matching index found");                        					break;                        
                    }                    
                }                            //If no matching index is found, then the selector does not match.                            if (j === matchInfo.matchingElements.length)                			{                                    //gcontext.TraceMessage("MatchSelector: matching index not found, return false");                    				return false;                    
                }                                            //Set the new ancestor to the element with a matching index attribute.                            ancestorHtmlElem = matchInfo.matchingElements[j];                
            }                    else                    {                            //The current XMLNode describes an element which is unique.                            //The match count must be 1 for unique elements.                            if (matchInfo.matchingElements.length !== 1)                			{                                    //gcontext.TraceMessage("MatchSelector: the current XMLNode must be unique but there are "+matchInfo.matchingElements.length+"matching elements, return false");                    				return false;                    
                }                            //Set the new ancestor                            ancestorHtmlElem = matchInfo.matchingElements[0];                
            }                        
        }                    //Success        	//gcontext.TraceMessage("MatchSelector: return true");            return true;        
    }        gcontext.GetNextInterestingParentForSelector = function (targetElem, requestIntermediateParents, outArgs) {            var out_interestingParentElem = null;                    var tagName = targetElem.tagName.toLowerCase();            if (tagName === "td" || tagName === "th" || tagName === "tr")                out_interestingParentElem = gcontext.GetParentByTag(targetElem, "table", requestIntermediateParents, outArgs);            else if (tagName === "option")                out_interestingParentElem = gcontext.GetParentByTag(targetElem, "select", requestIntermediateParents, outArgs);            else {                    //The target element is not a candidate for having an interesting parent.                    //Check if all the intermediate parents are requested.                    if (requestIntermediateParents === true && outArgs != null) {                            outArgs.intermediateParents = [];                                            var parentElem = targetElem.parentElement;                            while (parentElem != null && parentElem.nodeType === parentElem.ELEMENT_NODE) {                                    outArgs.intermediateParents.push(parentElem);                                    parentElem = parentElem.parentElement;                    
                }                
            }            
        }                    return out_interestingParentElem;        
    }        
}); // WrapInGlobalContextWrapInGlobalContext(function () {            var gcontext = this;            gcontext.g_traceEnabled = false;            gcontext.EnableTracing = function () {            gcontext.g_traceEnabled = true;        
    }        gcontext.DisableTracing = function () {            gcontext.g_traceEnabled = false;        
    }        gcontext.IsTracingEnabled = function () {        	return gcontext.g_traceEnabled;        
    }        gcontext.TraceMessage = function (msg) {            if (gcontext.g_traceEnabled) {                    try {                            console.log("UiPath : " + msg);                
            }                    catch (e) {                
            }            
        }        
    }        gcontext.TraceError = function (msg) {            if (gcontext.g_traceEnabled) {                    try {                            console.error("UiPath : " + msg);                
            }                    catch (e) {                
            }            
        }        
    }        gcontext.EnumObjectProps = function (obj, enumValues) {        	if (obj == null) {            		return "<null object>";            
        }                	var msg = "";        	for (var prop in obj) {            		var crtObj = null;                        		try {                			crtObj = obj[prop];                
            }            		catch (e) {                			crtObj = null;                
            }                        		if (crtObj == null) {                			continue;                
            }                        		var propVal = "";                        		if (typeof (crtObj) === "function") {                			propVal = "function {...}";                
            }            		else if (crtObj.toString == null) {                			propVal = "<" + typeof (crtObj) + ">";                
            }            		else {                			var MAX_VAL = 30;                			propVal = crtObj.toString();                                			if (propVal.length > MAX_VAL) {                    				propVal = propVal.slice(0, MAX_VAL) + "...";                    
                }                
            }                        		msg += prop;            		msg += (enumValues === true ? "=[" + propVal + "]\n" : ", ");            
        }                	return msg;        
    }        
}); // WrapInGlobalContextWrapInGlobalContext(function () {        var gcontext = this;    //This function gets the offsets between the Chrome window and the page rendering area, when nothing is displayed in the    //lower part of the browser window.    gcontext.GetPageRenderOffsets = function (refPageRenderOfsX, refPageRenderOfsY, pageZoomFactor)    {        	if (refPageRenderOfsX > 0 || refPageRenderOfsY > 0)        		return { x: refPageRenderOfsX, y: refPageRenderOfsY };                	var innerWidthPixels = window.innerWidth * pageZoomFactor;        	var innerHeightPixels = window.innerHeight * pageZoomFactor;        	var resizeBorderSize = (window.outerWidth - innerWidthPixels) / 2;                	//gcontext.TraceMessage("GetPageRenderOffsets: window.outerWidth="+window.outerWidth + " window.innerWidth="+window.innerWidth);        	//gcontext.TraceMessage("GetPageRenderOffsets: window.outerHeight="+window.outerHeight + " window.innerHeight="+window.innerHeight);        	//gcontext.TraceMessage("GetPageRenderOffsets: window.screenX="+window.screenX + " window.screenY="+window.screenY);                	return {            		x: resizeBorderSize,            		y: window.outerHeight - innerHeightPixels - resizeBorderSize            
        };        
    }        /* When transforming a point from on-screen coordinates to in-html(CSS) coordinates    we must pass through the following stages:                          Offset into browser                        Scale for device DPI    ====================  render page.         ====================  and page zoom level.    ==================    || 1. Screen Space ||--------------------> || 2. Client Space || ----------------------> || 3. CSS Space ||    ====================                       ====================                          ==================    This is what happens at each stage:    1.  Screen Space        The correct values for coordinates in this space can only be obtain from a process/thread that is per-monitor-DPI-aware.    2.  Screen Space -> Client Space        For web browsers, the origin of the html-render-page is different from that of the browser-top-level-window.        This is done in order to account for toolbars, border thickness, etc.         If we want to transform into Client-Space, then we need to obtain the correct values for this offset.                For Mozilla, this can obtained from (window.mozInnerScreenX, window.mozInnerScreenY).         These values must be scaled by window.devicePixelRatio to bring them in Screen-Space.                For Chrome, we have to compute this from the difference in position of the native windows for the browser and the html-render-page.    3.  Client Space -> CSS Space        To tranform into/out of this space, we must scale the coordinates by the device DPI and the page zoom level.        Both of these values are combined in window.devicePixelRatio, so it's sufficient to divide/multiply by this value.*/    gcontext.CssToScreenRect = function (cssRect, renderParams, useClientCoordinates)    {        	/* Expected values in 		renderParams		{			pageRenderOfsX  -> offset X of the html-render-page in the browser window			pageRenderOfsY  -> offset Y of the html-render-page in the browser window			pageZoomValue   -> the zoom level of current html page			windowLeft      -> origin X of the browser window)			windowTop       -> origin Y of the browser window		}		All the coordinates are in Screen-Space.	*/                	var clientToCssScaleFactor = window.devicePixelRatio;                	var finalRectangle = gcontext.CssToClientRect(cssRect, clientToCssScaleFactor);                	var isFirefox = (window.mozInnerScreenX !== undefined);        	var pageRenderOfs = { x: 0, y: 0 };        	if (isFirefox === false)        	{            		pageRenderOfs = gcontext.GetPageRenderOffsets(renderParams.pageRenderOfsX, renderParams.pageRenderOfsY, renderParams.pageZoomValue);            
        }        	finalRectangle = finalRectangle.Offset(pageRenderOfs.x, pageRenderOfs.y);                	//gcontext.TraceMessage("CssToScreenRect: windowScreenPos=("+window.screenX+" "+window.screenY+")");        	//gcontext.TraceMessage("CssToScreenRect: clientToCssScaleFactor="+clientToCssScaleFactor);        	//gcontext.TraceMessage("CssToScreenRect: renderParams.pageRenderOfs=("+renderParams.pageRenderOfsX+" "+renderParams.pageRenderOfsY+")");        	//gcontext.TraceMessage("CssToScreenRect: pageRenderOfs=("+pageRenderOfs.x+" "+pageRenderOfs.y+")");                	if (useClientCoordinates === N_FALSE)        	{            		var windowLeft = isFirefox ? (window.mozInnerScreenX * clientToCssScaleFactor) : renderParams.windowLeft;            		var windowTop = isFirefox ? (window.mozInnerScreenY * clientToCssScaleFactor) : renderParams.windowTop;                        		//gcontext.TraceMessage("CssToScreenRect: windowPos=("+windowLeft+" "+windowTop+")");                        		finalRectangle = finalRectangle.Offset(windowLeft, windowTop);            
        }        	return finalRectangle;        
    }        //This method converts CSS coordinates to client coordinates    //"cssRect" must be an UiRect object    gcontext.CssToClientRect = function (cssRect, zoomFactor)    {        	return cssRect.Scale(zoomFactor).MathRound();        
    }        gcontext.ScreenToCssPos = function (screenPos, renderParams)    {        	/* Expected values in 		renderParams		{			pageRenderOfsX  -> offset X of the html-render-page in the browser window			pageRenderOfsY  -> offset Y of the html-render-page in the browser window			pageZoomValue   -> the zoom level of current html page			windowLeft      -> origin X of the browser window)			windowTop       -> origin Y of the browser window		}		All the coordinates are in Screen-Space.	*/        	var clientToCssScaleFactor = window.devicePixelRatio;                	var isFirefox = (window.mozInnerScreenX !== undefined);        	var windowLeft = isFirefox ? (window.mozInnerScreenX * clientToCssScaleFactor) : (renderParams.windowLeft);        	var windowTop = isFirefox ? (window.mozInnerScreenY * clientToCssScaleFactor) : (renderParams.windowTop);                	var pageRenderOfs = { x: 0, y: 0 };        	if (isFirefox == false)        	{            		pageRenderOfs = gcontext.GetPageRenderOffsets(renderParams.pageRenderOfsX, renderParams.pageRenderOfsY, renderParams.pageZoomValue);            
        }                	// Transform the screen-coordinates to client-coordinates (think render page).        	var screenX = screenPos.x;        	var screenY = screenPos.y;        	var clientPos = { x: screenX - windowLeft - pageRenderOfs.x,                              y: screenY - windowTop - pageRenderOfs.y
    };    	// Transform the client-coordinates to CSS-coordinates.			 	      	var cssPos = gcontext.ClientToCssPos(clientPos, clientToCssScaleFactor);        	//gcontext.TraceMessage("ScreenToCssPos: clientToCssScaleFactor="+clientToCssScaleFactor);        //gcontext.TraceMessage("ScreenToCssPos: windowScreenPos=(" + window.screenX + " " + window.screenY + ")");        //gcontext.TraceMessage("ScreenToCssPos: windowScreenLeftTop=(" + window.screenLeft + " " + window.screenTop + ")");    	//gcontext.TraceMessage("ScreenToCssPos: windowPos=("+windowLeft+" "+windowTop+")");    	//gcontext.TraceMessage("ScreenToCssPos: renderParams.pageRenderOfs=("+renderParams.pageRenderOfsX+" "+renderParams.pageRenderOfsY+")");    	//gcontext.TraceMessage("ScreenToCssPos: pageRenderOfs=("+pageRenderOfs.x+" "+pageRenderOfs.y+")");    	//gcontext.TraceMessage("ScreenToCssPos: screenPos=("+screenX+" "+screenY+")");    	//gcontext.TraceMessage("ScreenToCssPos: clientPos=("+clientPos.x+" "+clientPos.y+")");    	//gcontext.TraceMessage("ScreenToCssPos: cssPos=("+cssPos.x+" "+cssPos.y+")");        	return cssPos;    
}        gcontext.ScreenToCssRect = function (screenRect, renderParams)    {        	/* Expected values in 		renderParams		{			pageRenderOfsX  -> offset X of the html-render-page in the browser window			pageRenderOfsY  -> offset Y of the html-render-page in the browser window			pageZoomValue   -> the zoom level of current html page			windowLeft      -> origin X of the browser window)			windowTop       -> origin Y of the browser window		}		All the coordinates are in Screen-Space.	*/        	var clientToCssScaleFactor = window.devicePixelRatio;                	var isFirefox = (window.mozInnerScreenX !== undefined);        	var windowLeft = isFirefox ? (window.mozInnerScreenX * clientToCssScaleFactor) : (renderParams.windowLeft);        	var windowTop = isFirefox ? (window.mozInnerScreenY * clientToCssScaleFactor) : (renderParams.windowTop);                	var pageRenderOfs = { x: 0, y: 0 };        	if(isFirefox == false)	{    		pageRenderOfs = gcontext.GetPageRenderOffsets(renderParams.pageRenderOfsX, renderParams.pageRenderOfsY, renderParams.pageZoomValue);    
}	// Transform the screen-coordinates to client-coordinates (think html render page).	var clientOffsetX = windowLeft + pageRenderOfs.x;	var clientOffsetY = windowTop + pageRenderOfs.y;	var clientRect = screenRect.Offset(-clientOffsetX, -clientOffsetY);	// Transform the client-coordinates to CSS-coordinates.			 	  	var cssRect = gcontext.ClientToCssRect(clientRect, clientToCssScaleFactor);	//gcontext.TraceMessage("ScreenToCssRect: clientToCssScaleFactor="+clientToCssScaleFactor);	//gcontext.TraceMessage("ScreenToCssRect: windowScreenPos=("+window.screenX+" "+window.screenY+")");	//gcontext.TraceMessage("ScreenToCssRect: windowPos=("+windowLeft+" "+windowTop+")");	//gcontext.TraceMessage("ScreenToCssRect: renderParams.pageRenderOfs=("+renderParams.pageRenderOfsX+" "+renderParams.pageRenderOfsY+")");	//gcontext.TraceMessage("ScreenToCssRect: pageRenderOfs=("+pageRenderOfs.x+" "+pageRenderOfs.y+")");	//gcontext.TraceMessage("ScreenToCssRect: screenRect="+RectToString(screenRect));	//gcontext.TraceMessage("ScreenToCssRect: cssRect=("+RectToString(cssRect));	return cssRect;}//This method converts client coordinates to CSS coordinates//"clientRect" must be an UiRect objectgcontext.ClientToCssRect = function (clientRect, zoomFactor){    	return clientRect.ScaleInv(zoomFactor).MathRound();    
}//This method converts client coordinates to CSS coordinatesgcontext.ClientToCssPos = function (clientPos, zoomFactor){    	//gcontext.TraceMessage("ClientToCssPos: scrollLeft=" + document.body.scrollLeft + " scrollTop=" + document.body.scrollTop);    	return {        		x: Math.round(clientPos.x / zoomFactor),        		y: Math.round(clientPos.y / zoomFactor)        
    };    
}// This method returns the left-top screen coordinates of a Chrome windowgcontext.GetChromeWindowScreenCoords = function (chromeWindow){    	return {
        left: chromeWindow.left,        	         top: chromeWindow.top
    };    
}//Chrome specific: the valid method is "initKeyboardEvent".gcontext.InitKeyboardEvent = function (event, type, canBubble, cancelable, view, keyCode, charCode, ctrlOn, altOn, shiftOn){        if (event.initKeyboardEvent) {                event.initKeyboardEvent(type, canBubble, cancelable, view,                        ctrlOn, altOn, shiftOn, false, keyCode, charCode);        
    }        else {                event.initKeyEvent(type, canBubble, cancelable, view, ctrlOn, altOn, shiftOn, false, keyCode, charCode);        
    }    
}//Chrome specific: object which communicates with the background page.gcontext.CreateBackgroundPageComm = function (portName){    	var m_crtRequestId = 0;    	var m_returnMap = {};    	var m_msgPort = chrome.runtime.connect({ name: portName });    	m_msgPort.onMessage.addListener(        		function (message)        		{            			if(message.returnId !== undefined )    			{        				//This message contains return data from the background page, resulting from a previous call to "CallFunction".        				//Invoke the callback function associated with this return data.        				//gcontext.TraceMessage("BackgroundPageComm::m_msgPort.onMessage: dismissing returnId = " + message.returnId);        				DismissReturnCallback(message.returnId, message);        
    }    
}	);	function RegisterReturnCallback(returnFunc)	{    		++m_crtRequestId;    		m_returnMap[m_crtRequestId] = returnFunc;    		return m_crtRequestId;    
}	function DismissReturnCallback(returnId, params)	{    		var returnFunc = m_returnMap[returnId];    		if (returnFunc !== undefined)    		{        			returnFunc(params);        			delete m_returnMap[returnId];        
    }    
}	return {    		//Sends a function call request to the background page. This happens because of Chrome API limitations in the content scripts.    		//Functions which need return data will receive the data on the "m_msgPort.onMessage" listener defined above.    		//After the return data is received, "returnFunc" will be called with the return data as an argument.    		CallFunction: function (functionName, inputParams, returnFunc)    		{    			if (returnFunc !== undefined)    				inputParams.requestId = RegisterReturnCallback(returnFunc);    			inputParams.functionCall = functionName;    			m_msgPort.postMessage(inputParams);    
},		Disconnect: function()		{    			m_msgPort.disconnect();    
}	};}}); // WrapInGlobalContextWrapInGlobalContext(function () {            var gcontext = this;        gcontext.CUSTOM_ID_SEPARATOR = "|";    gcontext.CUSTOM_ID_ATTR_NAME = "uipath_custom_id";        if (window.parent !== window) {            // elements in frames may be found using old selectors, which search through all allowed documents,            // or using new selectors, which limit search scope to a frame document. To avoid messing up the "custom_id"            // attribute, use different names for the main frame (legacy support) and other frames            gcontext.CUSTOM_ID_ATTR_NAME = "uipath_inframe_custom_id"        
    }        gcontext.ResetCustomIdCache = function ()    {        	gcontext.g_customIdCache = {};            gcontext.g_crtCustomIdValue = 0;        
    }        // For browser extension, g_customIdCache and g_crtCustomIdValue global vars come already initialized from Wrap.js.    // For webdriver, g_customIdCache and g_crtCustomIdValue global vars are undefined.        if ("undefined" != typeof g_crtCustomIdValue) {            // browser extension            gcontext.g_customIdCache = g_customIdCache;            gcontext.g_crtCustomIdValue = g_crtCustomIdValue; // see GenerateCustomId        
    } else {            // webdriver            if (typeof window.g_uipath_wd_cache !== "undefined") {                    gcontext.g_customIdCache = window.g_uipath_wd_cache.g_customIdCache;                    gcontext.g_crtCustomIdValue = window.g_uipath_wd_cache.g_crtCustomIdValue; // see GenerateCustomId            
        } else {                    console.error("assert: you should not be on this branch");            
        }        
    }        gcontext.GenerateCustomId = function ()    {            if ("undefined" != typeof g_crtCustomIdValue) {                    // browser extension only                    g_crtCustomIdValue++;                    gcontext.g_crtCustomIdValue = g_crtCustomIdValue;            
        } else {                    // webdriver only                    if (typeof window.g_uipath_wd_cache !== "undefined") {                            window.g_uipath_wd_cache.g_crtCustomIdValue++;                            gcontext.g_crtCustomIdValue = window.g_uipath_wd_cache.g_crtCustomIdValue;                
            } else {                            console.error("GenerateCustomId: assert: you should not be on this branch");                
            }            
        }                	return gcontext.g_crtCustomIdValue.toString();        
    }        gcontext.GenerateCustomIdForElement = function (elem)    {        	var out_customId = "";                	if (elem == null || elem.nodeType !== elem.ELEMENT_NODE)        		return out_customId;                	var attrCheck = elem.getAttribute(gcontext.CUSTOM_ID_ATTR_NAME);        	if (attrCheck != null)        	{            		//gcontext.TraceMessage("GenerateCustomIdForElement: the found element already has a customId=" + attrCheck);            		out_customId = attrCheck;            
        }        	else        	{            		out_customId = gcontext.GenerateCustomId();            		elem.setAttribute(gcontext.CUSTOM_ID_ATTR_NAME, out_customId);            		gcontext.g_customIdCache[out_customId] = elem;            		//gcontext.TraceMessage("GenerateCustomIdForElement: cached customId=" + out_customId);            
        }                	return out_customId;        
    }        gcontext.GetCustomIdForElement = function (elem)    {        	var out_customId = "";                	if (elem == null || elem.nodeType !== elem.ELEMENT_NODE)        		return out_customId;                	var attrCheck = elem.getAttribute(gcontext.CUSTOM_ID_ATTR_NAME);        	if (attrCheck != null)        		out_customId = attrCheck;                	return out_customId;        
    }        gcontext.ComputeCustomIdWithTabAndFrame_Impl = function (tabId, frameId, customIdNoTab)    {            if (typeof frameId === "undefined") {                    // webdriver case                    return tabId.toString() + CUSTOM_ID_SEPARATOR + customIdNoTab.toString();            
        }        	var out_idWithTabAndFrame = tabId.toString();                	if (customIdNoTab != null && customIdNoTab !== "")        		out_idWithTabAndFrame += gcontext.CUSTOM_ID_SEPARATOR + frameId.toString() + gcontext.CUSTOM_ID_SEPARATOR + customIdNoTab;                	return out_idWithTabAndFrame;        
    }        gcontext.ComputeCustomIdWithTabAndFrame = function (tabId, frameId, customIdNoTab)    {            // ComputeCustomIdWithTabAndFrame may be overwritten by webdriver support and, at the same time,            // maybe there is a need to call the original function (ComputeCustomIdWithTabAndFrame_Impl)            return gcontext.ComputeCustomIdWithTabAndFrame_Impl(tabId, frameId, customIdNoTab);        
    }        gcontext.SplitCustomIdWithFrame = function (customIdWithFrame)    {            var result = { frameId: 0, customId: "" };                    var idInfo = customIdWithFrame.split(gcontext.CUSTOM_ID_SEPARATOR);            if (idInfo.length === 2) {                    result.frameId = parseInt(idInfo[0]);                    result.customId = idInfo[1];            
        }                    return result;        
    }        
}); // WrapInGlobalContextwindow.chrome = window.chrome || window.browser;chrome.InitializeContentImpl = function (tab){    
}chrome.FinalizeContentImpl = function (tab){    
}WrapInGlobalContext(function () {            var gcontext = this;            // get a child frame's index in the parent window "frames" array    gcontext.GetChildFrameIndexInParent = function (frameWindow) {            // explicit check for Main (Top) Frame            if (gcontext.IsMainFrame(frameWindow))                return -1;                    var childrenArray = frameWindow.parent.frames;            for (var i = 0; i < childrenArray.length; i++) {                    if (childrenArray[i] === frameWindow) {                            return i;                
            }            
        }                    return -1;        
    }        // obtain frame info relevant for cross-origin algorithms    gcontext.GetCrossOriginFrameInfo = function () {            var indexInParent = gcontext.GetChildFrameIndexInParent(window);                    gcontext.TraceMessage("CrossOriginContent: Cross-origin frame info: indexInParent=" + indexInParent);            return {                    indexInParent: indexInParent            
        };        
    }        // get the HTML Element which contains a given child frame window,    // identified by its index in the current window "frames" array    gcontext.GetChildFrameElementByIndex = function (childFrameIndex) {                    // 1. get child frame window            var childWindow = window.frames[childFrameIndex];            if (childWindow === undefined) {                    return null;            
        }                    // 2. find the (i)frame element with the specified child frame window            var frameElementArray = window.document.getElementsByTagName("iframe");            for (var i = 0; i < frameElementArray.length; i += 1) {                    if (frameElementArray[i].contentWindow === childWindow) {                            return frameElementArray[i];                
            }            
        }                    frameElementArray = window.document.getElementsByTagName("frame");            for (var i = 0; i < frameElementArray.length; i += 1) {                    if (frameElementArray[i].contentWindow === childWindow) {                            return frameElementArray[i];                
            }            
        }                    return null;        
    }        //----------------------------------------------------------    // cross-origin call forwarding support for content scripts    //----------------------------------------------------------    gcontext.COFwdContent = function () {            return {                    GetFwdRequestInfo: function (message) {                            if (message != null && message.coFwdInfo != null) {                                    var out_coFwdInfo = message.coFwdInfo;                                    gcontext.TraceMessage("COFwdContent: Successfully read call forwarding info from " +                        (out_coFwdInfo.isParentSource ? "parent" : "childIndex=" + out_coFwdInfo.srcChildIndex));                                    return out_coFwdInfo;                    
                }                            return null;                
            },                                GetSrcChildElementFromRequest: function (coFwdInfo) {                            return coFwdInfo != null ? gcontext.GetChildFrameElementByIndex(coFwdInfo.srcChildIndex) : null;                
            },                                AppendFwdRequestToParentFrame: function (srcFrameId, customData, errorResult, out_result) {                            // The content page requests the parent frame to run a script with the current                            //frame as child index.                            gcontext.TraceMessage("COFwdContent: Created call forwarding request message to parent");                            if (out_result.coFwdRequests == null)                                out_result.coFwdRequests = [];                                            out_result.coFwdRequests.push({                                    srcFrameId: srcFrameId,                                    isParentDestination: true,                                    customData: customData,                                    errorResult: errorResult                    
                });                
            },                                AppendFwdRequestToChildFrame: function (srcFrameId, destChildElement, customData, errorResult, out_result) {                            var destWindow = destChildElement.contentWindow;                            if (!destWindow) {                                    gcontext.TraceError("COFwdContent: Call forwarding destination child element's \"contentWindow\" attribute is null/undefined");                                    return false;                    
                }                                            var childIndex = gcontext.GetChildFrameIndexInParent(destWindow);                            if (childIndex < 0) {                                    gcontext.TraceError("COFwdContent: Cannot get call forwarding destination child frame index in parent");                                    return false;                    
                }                                            gcontext.TraceMessage("COFwdContent: Created call forwarding request message to child element with index=" + childIndex);                            if (out_result.coFwdRequests == null)                                out_result.coFwdRequests = [];                                            gcontext.TraceMessage("CoFwdContent: errorResult " + gcontext.EnumObjectProps(errorResult, true));                                            out_result.coFwdRequests.push({                                    srcFrameId: srcFrameId,                                    isParentDestination: false,                                    destChildIndex: childIndex,                                    customData: customData,                                    errorResult: errorResult                    
                });                                            return true;                
            }            
        }        
    }            
}); // WrapInGlobalContextWrapInGlobalContext(function () {                var gcontext = this;                // AttributeValue matching types        gcontext.EMatchingType = {                Invalid: 0,                Normal: 1,                Regex: 2,                Fuzzy: 3,                FuzzyWords: 4        
    };            // Normal (aka Wildcard) Attribute Matcher        gcontext.NormalMatcher = function () {                this.Matches = function (attrInfo, text, caseSensitive) {                        return gcontext.StringWildcardMatch(attrInfo.value, text);            
        };        
    };            // RegEx Attribute Matcher        gcontext.RegexMatcher = function () {                        this.m_pattern = null;                this.m_caseSensitive = true;                this.m_regex = null;                        this.SetPattern = function (pattern, caseSensitive) {                        pattern = "^" + pattern + "$";  // force strict match (no substrings)                                    // avoid RegEx recompilation if the pattern didn't change                        if (this.m_regex !== null && this.m_pattern === pattern && this.m_caseSensitive === caseSensitive) {                                return;                
            }                        gcontext.TraceMessage("RegexMatcher::SetPattern pattern=\"" + pattern + "\" caseSensitive=" + caseSensitive);                                    this.m_pattern = pattern;                        this.m_caseSensitive = caseSensitive;                        this.m_regex = RegExp(this.m_pattern, caseSensitive ? "" : "i");  // flag "i" = case insensitive            
        };                        this.Matches = function (attrInfo, text, caseSensitive) {                        caseSensitive = typeof caseSensitive === "undefined" ? true : caseSensitive;                                    this.SetPattern(attrInfo.value, caseSensitive);                        var matchResult = this.m_regex.test(text);                                    gcontext.TraceMessage("RegexMatcher::Matches pattern=\"" + this.m_pattern + "\" text=\"" + text + "\" result=" + matchResult);                        return matchResult;            
        };        
    };            gcontext.FuzzyMatcher = function () {                function PreProcess(str) {                        // Remove all symbols except letters and numbers                        var res = str.replace(/[~!@#$%^&*()`;':\",./<>?]/gm, " ");                                    // Trim whitespace                        res = res.trim();                                    // force lowercase to facilitate sorting                        res = res.toLowerCase();                                    return res;            
        }                        function LevenshteinRatio(str1, str2) {                        var lensum = str1.length + str2.length;                                    var distance = LevenshteinEditDistance(str1, str2);                                    if (distance < 0) {                                return 0.0;                
            }                                    if (lensum == 0) {                                return 1.0;                
            }                                    if (lensum - distance == 0) {                                return 0.0;                
            }                                    return (lensum - distance) / lensum;            
        }                        function LevenshteinEditDistance(a, b) {                        // Create empty edit distance matrix for all possible modifications of                        // substrings of a to substrings of b.                        var i, j;                        var distanceMatrix = [];                                    for (j = 0; j <= b.length; j++) {                                distanceMatrix[j] = [];                
            }                                    // Fill the first row of the matrix.                        // If this is first row then we're transforming empty string to a.                        // In this case the number of transformations equals to size of a substring.                        for (i = 0; i <= a.length; i += 1) {                                distanceMatrix[0][i] = i;                
            }                                    // Fill the first column of the matrix.                        // If this is first column then we're transforming empty string to b.                        // In this case the number of transformations equals to size of b substring.                        for (j = 0; j <= b.length; j += 1) {                                distanceMatrix[j][0] = j;                
            }                                    for (j = 1; j <= b.length; j += 1) {                                for (i = 1; i <= a.length; i += 1) {                                        var indicator = a[i - 1] === b[j - 1] ? 0 : 2; // substitution costs 2 (1 deletion and 1 insertion)                                        distanceMatrix[j][i] = Math.min(                                                distanceMatrix[j][i - 1] + 1, // deletion                                                distanceMatrix[j - 1][i] + 1, // insertion                                                distanceMatrix[j - 1][i - 1] + indicator // substitution                        );                    
                }                
            }                                    return distanceMatrix[b.length][a.length];            
        }                        function TokenSort(a) {                        var tokens = a.split(" ");                        tokens.sort();                        return tokens.join(" ");            
        }                        function TokenSortRatio(a, b) {                        var sorted1 = TokenSort(a);                        var sorted2 = TokenSort(b);                                    return LevenshteinRatio(sorted1, sorted2);            
        }                        function GetUniqueTokens(tokens) {                        var set = new Array();                        for (var i = 0; i < tokens.length; ++i) {                                if (set.indexOf(tokens[i]) == -1) {                                        set.push(tokens[i]);                    
                }                
            }                        return set;            
        }                        function GetIntersection(set1, set2) {                        var intersection = new Array();                        for (var i = 0; i < set1.length; ++i) {                                if (set2.indexOf(set1[i]) != -1) { // set2 contains set1 value                                        intersection.push(set1[i]);                    
                }                
            }                        return intersection;            
        }                        function GetDifference(set1, set2) {                        var difference = new Array();                        for (var i = 0; i < set1.length; ++i) {                                if (set2.indexOf(set1[i]) == -1) { // set2 doesn't contain set1 value                                        difference.push(set1[i]);                    
                }                
            }                        return difference;            
        }                        function TokenSetRatio(a, b) {                                    var len1 = a.length;                        var len2 = b.length;                        if (len1 + len2 === 0) {                                return 1.0;                
            }                        if (len1 === 0 || len2 === 0) {                                return 0.0;                
            }                                    var tokens1 = a.split(" ");                        var tokens2 = b.split(" ");                                    // Can't use Set class because it is not available in Chrome 36; using Array instead                        var set1 = GetUniqueTokens(tokens1);                        var set2 = GetUniqueTokens(tokens2);                                    //Sort the array because it doesn't have a sorted iterator                        set1.sort();                        set2.sort();                                    var intersection = GetIntersection(set1, set2);                        var diff1to2 = GetDifference(set1, set2);                        var diff2to1 = GetDifference(set2, set1);                                    var sortedIntersection = intersection.join(" ");                        var sorted1to2 = diff1to2.join(" ");                        var sorted2to1 = diff2to1.join(" ");                                    var combined1to2 = sortedIntersection + " " + sorted1to2;                        var combined2to1 = sortedIntersection + " " + sorted2to1;                                    sortedIntersection = sortedIntersection.trim();                        combined1to2 = combined1to2.trim();                        combined2to1 = combined2to1.trim();                                    var m = Math.max(                            LevenshteinRatio(sortedIntersection, combined1to2),                            LevenshteinRatio(sortedIntersection, combined2to1),                            LevenshteinRatio(combined1to2, combined2to1)                        );            return m;        }        this.Matches = function (attrInfo, text, caseSensitive, fuzzyScoreStats) {                var fuzzyScore = 0;                    if (attrInfo.value === text) {                        fuzzyScore = 1.0;        
    }                else {                        var str1 = PreProcess(attrInfo.value);                        var str2 = PreProcess(text);                                var imperfectScale = 0.999;                        var unbaseScale = 0.95;                                var baseRatio = LevenshteinRatio(str1, str2) * imperfectScale;                        var tokenSortRatio = TokenSortRatio(str1, str2) * unbaseScale;  // imperfectScale already factored in                                fuzzyScore = Math.max(baseRatio, tokenSortRatio);        
    }                if (typeof fuzzyScoreStats !== "undefined") {                        fuzzyScoreStats.accept(fuzzyScore);        
    }                return fuzzyScore >= attrInfo.fuzzyLevel;    
};    };    // Selector Attribute Value    gcontext.AttributeValue = function (attrInfo) {                if (typeof attrInfo === "string") {                    this.m_info = { isNull: false, isActive: true, matchingType: gcontext.EMatchingType.Normal, value: attrInfo, fuzzyLevel: 0.0 };        
    }            else {                    this.m_info = attrInfo;  // isNull, isActive, matchingType, value, fuzzyLevel        
    }            this.m_matcher = null;   // used to test if the Attribute Value matches a string                this.InitializeMatcher = function () {                    this.m_matcher = null;                    if (this.m_info.isNull) {                            return;            
        }                            switch (this.m_info.matchingType) {                                        case gcontext.EMatchingType.Regex:                                    this.m_matcher = new gcontext.RegexMatcher();                                    break;                                case gcontext.EMatchingType.Fuzzy:                                case gcontext.EMatchingType.FuzzyWords:                                    this.m_matcher = new gcontext.FuzzyMatcher();                                    break;                                default:                                    this.m_matcher = new gcontext.NormalMatcher();                                    break;                
        }        
    };                this.InitializeMatcher();                this.GetInfo = function () {                    return this.m_info;        
    };                this.SetInfo = function (attrInfo) {                    this.m_info = attrInfo;                    this.InitializeMatcher();        
    };                this.Matches = function (text, caseSensitive, fuzzyScoreStats) {                    if (this.m_info.isNull) {                            return false;            
        }                    return this.m_matcher.Matches(this.m_info, text, caseSensitive, fuzzyScoreStats);        
    };    
};    gcontext.HasAttributeValue = function (attrValue) {            if (typeof attrValue === "undefined") {                    return false;        
    }                if (!attrValue instanceof gcontext.AttributeValue) {                    gcontext.TraceError("AttributeValue::HasAttributeValue invalid attrValue type: " + (typeof attrValue));                    return false;        
    }                var attrInfo = attrValue.GetInfo();            return attrInfo.isNull ? false : attrInfo.isActive;    
};    gcontext.GetActiveValueString = function (attrValue) {            return gcontext.HasAttributeValue(attrValue) ? attrValue.GetInfo().value : null;    
};    // return a map of AttributeValue objects    gcontext.AttributeValueMap = function (attrInfoMap) {            var attrValueMap = {};                Object.keys(attrInfoMap).forEach(                    function (key, index) {                            attrValueMap[key] = new gcontext.AttributeValue(attrInfoMap[key]);            
        });                return attrValueMap;    
};    // return a map of plain string values    gcontext.ActiveValueStringMap = function (attrValueMap) {            var activeValueMap = {};                Object.keys(attrValueMap).forEach(                    function (key, index) {                            activeValueMap[key] = gcontext.GetActiveValueString(attrValueMap[key]);            
        }        );                return activeValueMap;    
};    gcontext.IsUsingFuzzyAttributes = function (attrValueMap) {            var res = false;            Object.values(attrValueMap).forEach(                    function (value) {                                        if (value.GetInfo().matchingType === gcontext.EMatchingType.Fuzzy || value.GetInfo().matchingType === gcontext.EMatchingType.FuzzyWords) {                                                    res = true;                
            }            
        }        );            return res;    
};}); // WrapInGlobalContext